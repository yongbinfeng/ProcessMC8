#include <iostream>
#include <iomanip>
#include <locale>

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>

#include "vector"
#include "vector"
using std::vector;
#include "list"
#include "algorithm"

#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>

TTree          *fChain;   //!pointer to the analyzed TTree or TChain               
Int_t           fCurrent; //!current Tree number in a TChain                       


int iDBG=1;
int iSDBG=1;
float pilecut=1.5;
float pilecut2=1.5;

float DeltaR(float eta1, float phi1, float eta2, float phi2) {

  float dR=0.;
  float deta = std::fabs(eta1-eta2);
  float dphi = std::fabs(phi1-phi2);
  if(dphi>3.14159) dphi = 2.*3.14159-dphi;
  dR=std::sqrt(deta*deta+dphi*dphi);

  return dR;
}



int EMJselect(bool otfile, bool hasPre, const char* inputfilename,const char* outputfilename,
	      float HTcut, float pt1cut, float pt2cut, float pt3cut, float pt4cut, float jetacut,float alphaMaxcut, float maxIPcut, float NemfracCut,float CemfracCut,int ntrk1cut, int NemergingCut,bool blind,
	      float Dmetcut, float Dmass, float Dmasscut, float Dtheta2dcut
) {
  // "ntuple.root", "histos.root"
  // suggest cuts 1000., 400.,200.,125.,50.,0.2,0.9,0.9,0,1
  // right now this code hard wires the jet pT cut and requires emerging jets to have at least
  // one track with pT> 1 GeV

  // read the Tree generated by tree1w and fill two histograms
  // note that we use "new" to create the TFile and TTree objects,
  // to keep them alive after leaving this function.
 
  int npass=0;

  TFile *f = new TFile(inputfilename);

  // get histogram of events before trigger
  TH1F *eventCountPreTrigger;

  if(hasPre) {
    if(otfile) eventCountPreTrigger = static_cast<TH1F*>(f->Get("eventCountPreTrigger/eventCountPreTrigger")->Clone());
  } else {
    if(otfile)  eventCountPreTrigger = new TH1F("eventCountPreTrigger","haha",2,0.,2.);
  }



  TTree *tt = (TTree*)f->Get("emJetAnalyzer/emJetTree");

  Int_t nVtx, event, lumi, run, nTrueInt, nTracks, pv_indexInColl;
  Float_t met_pt, met_phi;

  //pv
  float pv_x,pv_y,pv_z;


  // gen particles
  vector<int> *gp_index=new vector<int>;
  vector<int> *gp_pdgId=new vector<int>;
  vector<float> *gp_pt = new vector<float>;
  vector<float> *gp_eta = new vector<float>;
  vector<float> *gp_phi = new vector<float>;
  vector<int> *gp_charge = new vector<int>;
  vector<int> *gp_status = new vector<int>;
  vector<float> *gp_vx = new vector<float>;
  vector<float> *gp_vy = new vector<float>;
  vector<float> *gp_vz = new vector<float>;

  // jet
  vector<int> *jet_index=new vector<int>;
  vector<int> *jet_source=new vector<int>;
  vector<float> *jet_pt = new vector<float>;
  vector<float> *jet_eta = new vector<float>;
  vector<float> *jet_phi = new vector<float>;
  vector<float> *jet_alphaMax = new vector<float>;
  vector<float> *jet_theta2D = new vector<float>;
  vector<float> *jet_cef = new vector<float>;
  vector<float> *jet_nef = new vector<float>;
  vector<float> *jet_chf = new vector<float>;
  vector<float> *jet_nhf = new vector<float>;
  //  vector<float> *jet_phf = new vector<float>;
  vector<vector<float> > *track_pt = 0;
  vector<vector<float> > *track_eta = 0;
  vector<vector<float> > *track_phi = 0;
  vector<vector<float> > *track_pvWeight =0;
  vector<vector<int> > *track_source = 0;
  vector<vector<int> > *track_quality = 0;
  vector<vector<int> > *track_index = 0;
  vector<vector<int> > *track_jet_index = 0;
  vector<vector<int> > *track_algo = 0;
  vector<vector<float> > *track_ipZ =0;
  vector<vector<float> > *track_ipXY = 0;
  vector<vector<float> > *track_ipXYSig = 0;
  vector<vector<float> > *track_ref_x =0;
  vector<vector<float> > *track_ref_y =0;
  vector<vector<float> > *track_ref_z =0;
  vector<vector<int> > *track_nMissInnerHits = 0;
  vector<vector<int> > *track_nMissInnerTrkLayers = 0;
  vector<vector<int> > *track_nMissOuterTrkLayers = 0;
  vector<vector<int> > *track_nMissInnerPxlLayers = 0;
  vector<vector<int> > *track_nPxlLayers = 0;
  vector<vector<int> > *track_nHits = 0;


  
  

  //get event count pre trigger



  //for ntuple
  // gen particles
  tt->SetBranchAddress("gp_index",&gp_index);
  tt->SetBranchAddress("gp_pdgId",&gp_pdgId);
  tt->SetBranchAddress("gp_pt",&gp_pt);
  tt->SetBranchAddress("gp_eta",&gp_eta);
  tt->SetBranchAddress("gp_phi",&gp_phi);
  tt->SetBranchAddress("gp_charge",&gp_charge);
  tt->SetBranchAddress("gp_status",&gp_status);
  tt->SetBranchAddress("gp_vx",&gp_vx);
  tt->SetBranchAddress("gp_vy",&gp_vy);
  tt->SetBranchAddress("gp_vz",&gp_vz);


  // vertices
  tt->SetBranchAddress("nVtx",&nVtx);
  tt->SetBranchAddress("nTrueInt",&nTrueInt);
  tt->SetBranchAddress("nTracks",&nTracks);
  tt->SetBranchAddress("pv_x",&pv_x);
  tt->SetBranchAddress("pv_y",&pv_y);
  tt->SetBranchAddress("pv_z",&pv_z);
  tt->SetBranchAddress("pv_indexInColl",&pv_indexInColl);

  // general event information
  tt->SetBranchAddress("event",&event);
  tt->SetBranchAddress("lumi",&lumi);
  tt->SetBranchAddress("run",&run);
  tt->SetBranchAddress("met_pt",&met_pt);
  tt->SetBranchAddress("met_phi",&met_phi);

  //jets
  tt->SetBranchAddress("jet_index",&jet_index);
  tt->SetBranchAddress("jet_source",&jet_source);
  tt->SetBranchAddress("jet_pt",&jet_pt);
  tt->SetBranchAddress("jet_eta",&jet_eta);
  tt->SetBranchAddress("jet_phi",&jet_phi);
  tt->SetBranchAddress("jet_cef",&jet_cef);
  tt->SetBranchAddress("jet_nef",&jet_nef);
  tt->SetBranchAddress("jet_chf",&jet_chf);
  tt->SetBranchAddress("jet_nhf",&jet_nhf);
  //  tt->SetBranchAddress("jet_phf",&jet_phf);
  tt->SetBranchAddress("jet_alphaMax",&jet_alphaMax);
  tt->SetBranchAddress("jet_theta2D",&jet_theta2D);
  tt->SetBranchAddress("track_pt",&track_pt);
  tt->SetBranchAddress("track_eta",&track_eta);
  tt->SetBranchAddress("track_phi",&track_phi);
  tt->SetBranchAddress("track_pvWeight",&track_pvWeight);
  tt->SetBranchAddress("track_source",&track_source);
  tt->SetBranchAddress("track_quality",&track_quality);
  tt->SetBranchAddress("track_index",&track_index);
  tt->SetBranchAddress("track_jet_index",&track_jet_index);
  tt->SetBranchAddress("track_algo",&track_algo);
  tt->SetBranchAddress("track_ipXY",&track_ipXY);
  tt->SetBranchAddress("track_ipZ",&track_ipZ);
  tt->SetBranchAddress("track_ref_x",&track_ref_x);
  tt->SetBranchAddress("track_ref_y",&track_ref_y);
  tt->SetBranchAddress("track_ref_z",&track_ref_z);
  tt->SetBranchAddress("track_ipXYSig",&track_ipXYSig);
  tt->SetBranchAddress("track_nMissInnerHits",&track_nMissInnerHits);
  tt->SetBranchAddress("track_nMissInnerPxlLayers",&track_nMissInnerPxlLayers);
  tt->SetBranchAddress("track_nMissOuterTrkLayers",&track_nMissOuterTrkLayers);
  tt->SetBranchAddress("track_nMissInnerTrkLayers",&track_nMissInnerTrkLayers);
  tt->SetBranchAddress("track_nPxlLayers",&track_nPxlLayers);
  tt->SetBranchAddress("track_nHits",&track_nHits);
  tt->SetBranchAddress("track_ipZ",&track_ipZ);

  

  

  // create a histograms
  TH1F *acount,*count,*hjetcut,*hjetchf,*h_nemg,*hnjet,*hpt,*heta,*heta2,*halpha,*H_T,*H_T2,*H_T3,*H_T4,*hbcut_ntrkpt1,*hacut_ntrkpt1,*hbcut_nef,*hacut_nef,*hbcut_cef,*hacut_cef,*hbcut_alphamax,*hacut_alphamax,*hbcut_theta2d,*hbcut_maxip,*hmetnm1,*hmassnm1,*htheta2D1nm1,*htheta2D2nm1,*htheta2D3nm1,*htheta2D4nm1,*hHTnm1,*hnHitsnm1,*hntrk1nm1,*hmaxipnm1,*hpt1nm1,*hpt2nm1,*hpt3nm1,*hpt4nm1,*halphanm1,*hnemnm1,*hpt1,*hpt2,*hpt3,*hpt4,*hipXYEJ,*hipXYnEJ,*htvw,*htvwEJ,*hnmaxipnm1,*hn2maxipnm1,*hjptfrb,*hjptfra1,*hjptfra2,*hjptfrbc,*hjptfra1c,*hjptfra2c,*hjptb,*hjpta,*haMgj,*hHTko,*hpt1ko,*hpt2ko,*hpt3ko,*hpt4ko,*hipXYSigEJ,*hipXYSignEJ,*hmaxipXYEJ,*hmaxipXYnEJ,*hmeanipXYEJ,*hmeanipXYnEJ,*hmass,
    *hdkjetam,*hdkjetmeanip,*hdkjetntr,*hdkjetmaxip,*hdkjettrkip,*hdkjettrkips,*hdkjettrkw,*hdkjettrgip,*hdkjettrkdr,*ham2dfd,*ham2dfdk,*hdkjetamo,*hdjetamo,*hdzjpre,*hdzjfinal,
    *hdjetam,*hdjetmeanip,*hdjetntr,*hdjetmaxip,*hdjettrkip,*hdjettrkips,*hdjettrkw,*hdjettrgip,*hdjettrkdr,*hdjetam2d,*hdkjetam2d,*hmeanz,*hmeanzfa,*hmeanzpa,*hmeanzdk,*hmeanzd,*h2dpa,*h2dfa,*hntrkpt1zmpa,*hntrkpt1zmfa,*hbigb,*hpvpre,*hpvfinal,*hdzpre,*hdzfinal,*hmeanzpre,*hmeanzfinal,
    *hnvtxpre,*hnvtxfinal,*hntrkpre,*hntrkfinal,*hjetptfrpre,*hjetptfrfinal,
    *hjntrkpre,*hjntrkfinal,*hfpilepre,*hfpilefinal,*hptmaxpre,*hptmaxfinal,*hsum2Dfpre,*hsum2Dffinal,*hsum2Dfd,*hsum2Dfdk,
    *hptallpre,*hptudpre,*hptcpre,*hptspre,*hptgbbpre,*hptbpre,*hptgpre,
    *hptallfinal,*hptudfinal,*hptcfinal,*hptsfinal,*hptgbbfinal,*hptbfinal,*hptgfinal,
    *hptallfinal2,*hptudfinal2,*hptcfinal2,*hptsfinal2,*hptgbbfinal2,*hptbfinal2,*hptgfinal2,
    *hptallpree,*hptudpree,*hptcpree,*hptspree,*hptgbbpree,*hptbpree,*hptgpree,
    *hptallfinale,*hptudfinale,*hptcfinale,*hptsfinale,*hptgbbfinale,*hptbfinale,*hptgfinale,
    *ham2dfb,*ham2dfgbb,*ham2dfg,*ham2dfud,
    *ham2dfbpt1,*ham2dfbpt2,*ham2dfbpt3,
    *ham2dfudpt1,*ham2dfudpt2,*ham2dfudpt3
;

  TH1F *hmzamd,*hmznamd,*h2damd,*h2dnamd;

  TH2F *aMip,*haMvjpt,*haMvHT,*haMvnvtx,*aMbh,*aMbh2D,*aMbh2Daem,*aMbh2Dd,*aMbh2Ddk,*aMmzd,*aMmzdk,
    *adkwvd0,*adkwviz,
    *adwvd0,*adwviz,*adk2Dr0,*ad2Dr0,*hdkipphi,*hdipphi
  ;

  if(otfile) {
  acount = new TH1F("acount","counts",20,0.,20.);
  count = new TH1F("count","counts",3,0,3);
  count->SetStats(0);
  count->SetCanExtend(TH1::kAllAxes);

  // 1d
  hjetcut = new TH1F("hjetcut","jetcut counts",20,0.,20.);
  hjetchf = new TH1F("hjetchf","jet charged hadron fr",20,0.,1.2);
  h_nemg = new TH1F("h_nemg","number of emerging jets",20,0.,20.);
  hnjet = new TH1F("hnjet","number of jets",20,0.,20.);
  hpt = new TH1F("hpt","jet pt distribution",200,0.,1000.);
  heta   = new TH1F("heta","jet eta distribution",100,-4.,4.);
  heta2   = new TH1F("heta2","jet eta distribution first 4 jets",100,-4.,4.);
  halpha   = new TH1F("halpha","jet alphaMax distribution",100,0.,1.5);
  haMgj   = new TH1F("haMgj","jet alphaMax distribution, good jets",100,0.,1.5);
  H_T      = new TH1F("H_T"," HT distribution before cut", 100,0.,5000.);
  H_T2      = new TH1F("H_T2"," HT distribution after cut", 100,0.,5000.);
  H_T3      = new TH1F("H_T3"," HT distribution at end", 100,0.,5000.);
  H_T4      = new TH1F("H_T4"," HT distribution test", 100,0.,5000.);
  hpt1 = new TH1F("hpt1"," pT of leading jet",200,0.,1000.);
  hpt2 = new TH1F("hpt2"," pT of second jet",200,0.,1000.);
  hpt3 = new TH1F("hpt3"," pT of third jet",200,0.,1000.);
  hpt4 = new TH1F("hpt4"," pT of fourth jet",200,0.,1000.);
  hbcut_ntrkpt1 = new TH1F("hbcut_ntrkpt1","number tracks pt>1 before cut",20,0.,20.);
  hacut_ntrkpt1 = new TH1F("hacut_ntrkpt1","number tracks pt>1 after cut",20,0.,20.);
  hbcut_nef = new TH1F("hbcut_nef","neutral em fraction before cut",10,0.,1.2);
  hacut_nef = new TH1F("hacut_nef","neutral em fraction after cut",10,0.,1.2);
  hbcut_cef = new TH1F("hbcut_cef","charged em fraction before cut",50,0.,1.2);
  hacut_cef = new TH1F("hacut_cef","charged em fraction after cut",50,0.,1.2);
  hbcut_alphamax = new TH1F("hbcut_alphamax","alphamax before cut",50,0.,1.5);
  hacut_alphamax = new TH1F("hacut_alphamax","alphamax after cut",50,0.,1.5);
  hbcut_maxip = new TH1F("hbcut_maxip","maxip before cut",50,0.,30.);
  hbcut_theta2d = new TH1F("hbcut_theta2d","theta2d before cut",50,0.,0.1);
  hHTnm1 = new TH1F("hHTnm1","HT n-1",100,0.,5000.);
  hmassnm1 = new TH1F("hmassnm1","mass n-1",100,-10.,5000.);
  htheta2D1nm1 = new TH1F("htheta2D1nm1","log10 theta2D jet1 n-1",50,-3.5,0.5);
  htheta2D2nm1 = new TH1F("htheta2D2nm1","log10 theta2D jet2 n-1",50,-3.5,0.5);
  htheta2D3nm1 = new TH1F("htheta2D3nm1","log10 theta2D jet3 n-1",50,-3.5,0.5);
  htheta2D4nm1 = new TH1F("htheta2D4nm1","log10 theta2D jet4 n-1",50,-3.5,0.5);
  hmetnm1 = new TH1F("hmetnm1","MET n-1",100,0.,500.);
  hpt1nm1 = new TH1F("hpt1nm1","pt1 n-1",200,0.,1000.);
  hpt2nm1 = new TH1F("hpt2nm1","pt2 n-1",200,0.,1000.);
  hpt3nm1 = new TH1F("hpt3nm1","pt3 n-1",200,0.,1000.);
  hpt4nm1 = new TH1F("hpt4nm1","pt4 n-1",200,0.,1000.);
  halphanm1 = new TH1F("halphanm1","alpha max n-1",200,0.,1.5);
  hmaxipnm1 = new TH1F("hmaxipnm1","ip max n-1",200,0.,10.);
  hnmaxipnm1 = new TH1F("hnmaxipnm1","new 2 ip max n-1",200,0.,10.);
  hn2maxipnm1 = new TH1F("hn2maxipnm1","new 1  ip max n-1",200,0.,10.);
  hnHitsnm1 = new TH1F("hnHitsnm1","number Hits n-1",40,0.,40.);
  hntrk1nm1 = new TH1F("hntrk1nm1","number tracks pt>1 n-1",50,0.,50.);
  hnemnm1 = new TH1F("hnemnm1","N emerging jets n-1",10,0.,10.);
  hipXYEJ = new TH1F("hipXYEJ","impact parameter  tracks of emerging jets",300,0,0.2);
  hipXYnEJ = new TH1F("hipXYnEJ","impact parameter  tracks of not emerging jets",300,0.,0.2);
  htvw = new TH1F("htvw","track vertex weight ",150,-5.,1.);
  htvwEJ= new TH1F("htvwEJ","track vertex weight Emerging Jets ",15,-5.,10.);
  hipXYSigEJ = new TH1F("hipXYSigEJ","ip sig emerging jets",100,0.,10.);
  hipXYSignEJ = new TH1F("hipXYSignEJ","ip sig not emerging jets",100,0.,10.);
  hmaxipXYEJ = new TH1F("hmaxipXYEJ","max ip emerging jets",1000,0.,10.);
  hmaxipXYnEJ = new TH1F("hmaxipXYnEJ","max ip not emerging jets",1000,0.,10.);
  hmeanipXYEJ = new TH1F("hmeanipXYEJ","mean ip emerging jets",1000,0.,2.);
  hmeanipXYnEJ = new TH1F("hmeanipXYnEJ","mean ip not emerging jets",1000,0.,2.);
  hjptb = new TH1F("hjptb"," pT of basic jet",100,0.,1000.);
  hjpta = new TH1F("hjpta"," pT of emergng jets",100,0.,1000.);
  hjptfrb = new TH1F("hjptfrb"," pT of basic jets passing kine selection and n<4",100,0.,1000.);
  hjptfra1 = new TH1F("hjptfra1"," pT of basic jets passing kine, almost selection and n<4",100,0.,1000.);
  hjptfra2 = new TH1F("hjptfra2"," pT of basic jets passing kine, almost, and emerging selection and n<4",100,0.,1000.);
  hjptfrbc = new TH1F("hjptfrbc"," pT of basic jets passing kine selection",100,0.,1000.);
  hjptfra1c = new TH1F("hjptfra1c"," pT of basic jets passing kine, almost selection",100,0.,1000.);
  hjptfra2c = new TH1F("hjptfra2c"," pT of basic jets passing kine, almost, and emerging selection",100,0.,1000.);
  hHTko      = new TH1F("hHTko"," HT distribution test kine cuts", 100,0.,5000.);
  hpt1ko = new TH1F("hpt1ko"," pT of leading jet kine cuts",200,0.,1000.);
  hpt2ko = new TH1F("hpt2ko"," pT of second jet kine cuts",200,0.,1000.);
  hpt3ko = new TH1F("hpt3ko"," pT of third jet kine cuts",200,0.,1000.);
  hpt4ko = new TH1F("hpt4ko"," pT of fourth jet kine cuts",200,0.,1000.);
  hmass = new TH1F("hmass","mass emerging and non",500,-10.,5000.);

  hdkjetam = new TH1F("hdkjetam","alphamax dark quark jets ",100,0.,1.);
  hdkjetamo = new TH1F("hdkjetamo","old alphamax dark quark jets ",100,0.,1.);
  hdjetamo = new TH1F("hdjetamo","old alphamax down quark jets ",100,0.,1.);
  hdkjetam2d = new TH1F("hdkjetam2d","alphamax2d dark quark jets ",100,0.,1.);
  ham2dfd = new TH1F("ham2dfd","alpha2d sig down quark jets ",100,0.,1.);
  ham2dfb = new TH1F("ham2dfb","alpha2d sig b quark jets ",100,0.,1.);
  ham2dfgbb = new TH1F("ham2dfgbb","alpha2d sig glue to bb quark jets ",100,0.,1.);
  ham2dfg = new TH1F("ham2dfg","alpha2d sig  glu jets ",100,0.,1.);
  ham2dfud = new TH1F("ham2dfud","alpha2d sig u,d quark jets ",100,0.,1.);
  ham2dfdk = new TH1F("ham2dfdk","alpha2d sig dark quark jets ",100,0.,1.);

  ham2dfbpt1 = new TH1F("ham2dfbpt1","alpha2d sig b quark jets pt 100-300 ",100,0.,1.);
  ham2dfbpt2 = new TH1F("ham2dfbpt2","alpha2d sig b quark jets pt 300-600 ",100,0.,1.);
  ham2dfbpt3 = new TH1F("ham2dfbpt3","alpha2d sig b quark jets pt >600 ",100,0.,1.);
  ham2dfudpt1 = new TH1F("ham2dfudpt1","alpha2d sig ud quark jets pt 100-300 ",100,0.,1.);
  ham2dfudpt2 = new TH1F("ham2dfudpt2","alpha2d sig ud quark jets pt 300-600 ",100,0.,1.);
  ham2dfudpt3 = new TH1F("ham2dfudpt3","alpha2d sig ud quark jets pt >600 ",100,0.,1.);

  hdkjetmeanip = new TH1F("hdkjetmeanip","mean ip dark quark jets",100,0.,10.);
  hdkjetmaxip = new TH1F("hdkjetmaxip","max ip dark quark jets",100,0.,30.);
  hdkjetntr = new TH1F("hdkjetntr","number tracks pt>1 dark quark jets",100,0.,50.);
  hdkjettrkip = new TH1F("hdkjettrkip","2d ip tracks in dark quark jets",100,0.,2.);
  hdkjettrkips = new TH1F("hdkjettrkips","2d ip sig tracks in dark quark jets",100,0.,5.);
  hdkjettrkw = new TH1F("hdkjettrkw","track pv weight in dark quark jets",100,-1.2,1.2);
  hdkjettrgip = new TH1F("hdkjettrgip","gen r0 charged part in dark quark jets",100,0.,5.);
  hdkjettrkdr = new TH1F("hdkjettrkdr","gen trk dr charged part in dark quark jets",100,0.,1.);

  hdjetam = new TH1F("hdjetam","alphamax down quark jets ",100,0.,1.);
  hdjetam2d = new TH1F("hdjetam2d","alphamax2d down quark jets ",100,0.,1.);
  hdjetmeanip = new TH1F("hdjetmeanip","mean ip down quark jets",100,0.,10.);
  hdjetmaxip = new TH1F("hdjetmaxip","max ip down quark jets",100,0.,30.);
  hdjetntr = new TH1F("hdjetntr","number tracks pt>1 down quark jets",100,0.,50.);
  hdjettrkip = new TH1F("hdjettrkip","2d ip tracks in down quark jets",100,0.,2.);
  hdjettrkips = new TH1F("hdjettrkips","2d ip sig tracks in down quark jets",100,0.,5.);
  hdjettrkw = new TH1F("hdjettrkw","track pv weight in down quark jets",100,-1.2,1.2);
  hdjettrgip = new TH1F("hdjettrgip","gen r0 charged part in down quark jets",100,0.,5.);
  hdjettrkdr = new TH1F("hdjettrkdr","gen trk dr charged part in down quark jets",100,0.,1.);
  hmeanz = new TH1F("hmeanz","diff pvz and mean jet z",100,-5.,5.);
  hmeanzd = new TH1F("hmeanzd","diff pvz and mean jet z down quarks",100,-5.,5.);
  hmeanzdk = new TH1F("hmeanzdk","diff pvz and mean jet z dark quarks",100,-5.,5.);

  hmeanzfa = new TH1F("hmeanzfa","diff pvz and mean jet z failling almost emerging",500,-5.,5.);
  hmeanzpa = new TH1F("hmeanzpa","diff pvz and mean jet z pass almost emerging",500,-5.,5.);


  hmeanzpre = new TH1F("hmeanzpre","diff pvz and mean jet z preselection",500,-5.,5.);
  hmeanzfinal = new TH1F("hmeanzfinal","diff pvz and mean jet z pass final selection",500,-5.,5.);

  hdzjpre = new TH1F("hdzjpre","max diff median z 4 jets preselection",250,0.,20.);
  hdzjfinal = new TH1F("hdzjfinal","max diff median z 4 jets final selection" ,250,0.,20.);

  hsum2Dfpre = new TH1F("hsum2Dfpre","fract track ipsig preselection",100,0.,1.1);
  hsum2Dffinal = new TH1F("hsum2Dffinal","fract track ipsig final selection",100,0.,1.1);
  hsum2Dfd = new TH1F("hsum2Dfd","fract track ipsig down quarks",100,0.,1.1);
  hsum2Dfdk = new TH1F("hsum2Dfdk","fract track ipsig dark quarks",100,0.,1.1);

  hntrkpt1zmpa = new TH1F("hntrkpt1zmpa","number tracks in jet matching pv pass almost",30,0.,30.);
  hntrkpt1zmfa = new TH1F("hntrkpt1zmfa","number tracks in jet matching pv failing almost",30,0.,30.);

  h2dpa = new TH1F("h2dpa","alpha2d z pass almost emerging",100,0.,1.);
  h2dfa = new TH1F("h2dfa","alpha2d z fail almost emerging",100,0.,1.);
  hmzamd = new TH1F("hmzamd","meanz down quarks almost emerging",100,-7.,7.);
  hmznamd = new TH1F("hmznamd","meanz down quarks not almost emerging",100,-7.,7.);
  h2damd = new TH1F("h2damd","alpha2d down quarks almost emerging",100,0.,1.);
  h2dnamd = new TH1F("h2dnamd","alpha2d down quarks not almost emerging",100,0.,1.);

  hbigb = new TH1F("hbigb","delta R emerging jet and nearest big b",100,-2,5.);
  hpvpre = new TH1F("hpvpre","pv z preselection",100,-30.,30.);
  hpvfinal = new TH1F("hpvfinal","pv z final",100,-30.,30.);

  hdzpre = new TH1F("hdzpre","delta z pv track  preselection",400,-40.,40.);
  hdzfinal = new TH1F("hdzfinal","delta z pv track final",400,-40.,40.);


  hnvtxpre = new TH1F("hnvtxpre","nvtx  preselection",50,-0.,100.);
  hnvtxfinal = new TH1F("hnvtxfinal","nvtx final",50,0.,100.);

  hntrkpre = new TH1F("hntrkpre","ntrk  preselection",100,0.,3000.);
  hntrkfinal = new TH1F("hntrkfinal","nntrk final",100,0.,3000.);


  hjntrkpre = new TH1F("hjntrkpre","jet ntrk  preselection",100,0.,100.);
  hjntrkfinal = new TH1F("hjntrkfinal","jet nntrk final",100,0.,100.);


  hjetptfrpre = new TH1F("hjetptfrpre","fract jet pt leading track  preselection",100,0.,1.5);
  hjetptfrfinal = new TH1F("hjetptfrfinal","fract jet pt leading track final",100,0.,1.5);

  hfpilepre = new TH1F("hfpilepre","fract jet pt pileup  preselection",100,0.,1.5);
  hfpilefinal = new TH1F("hfpilefinal","fract jet pt pileup  final selection",100,0.,1.5);


  hptmaxpre = new TH1F("hptmaxpre","pt highest pt track preselection",400,0.,400.);
  hptmaxfinal = new TH1F("hptmaxfinal","pt highest pt track final selection",400,0.,400.);

  hptallpre = new TH1F("hptallpre","pt all jets passing preselection",500,0.,1500.);
  hptudpre = new TH1F("hptudpre","pt ud jets passing preselection",500,0.,1500.);
  hptspre = new TH1F("hptspre","pt s jets passing preselection",500,0.,1500.);
  hptcpre = new TH1F("hptcpre","pt c jets passing preselection",500,0.,1500.);
  hptbpre = new TH1F("hptbpre","pt b jets passing preselection",500,0.,1500.);
  hptgpre = new TH1F("hptgpre","pt g jets passing preselection",500,0.,1500.);
  hptgbbpre = new TH1F("hptgbbpre","pt gbb jets passing preselection",500,0.,1500.);

  hptallpree = new TH1F("hptallpree","pt allemerging jets passing preselection",500,0.,1500.);
  hptudpree = new TH1F("hptudpree","pt ud emerging jets passing preselection",500,0.,1500.);
  hptspree = new TH1F("hptspree","pt s emerging jets passing preselection",500,0.,1500.);
  hptcpree = new TH1F("hptcpree","pt c emerging jets passing preselection",500,0.,1500.);
  hptbpree = new TH1F("hptbpree","pt b emerging jets passing preselection",500,0.,1500.);
  hptgpree = new TH1F("hptgpree","pt g emerging jets passing preselection",500,0.,1500.);
  hptgbbpree = new TH1F("hptgbbpree","pt gbb emerging jets passing preselection",500,0.,1500.);


  hptallfinal = new TH1F("hptallfinal","pt all jets passing 1 emerging",500,0.,1500.);
  hptudfinal = new TH1F("hptudfinal","pt ud jets passing 1 emerging",500,0.,1500.);
  hptsfinal = new TH1F("hptsfinal","pt s jets passing 1 emerging",500,0.,1500.);
  hptcfinal = new TH1F("hptcfinal","pt c jets passing 1 emerging",500,0.,1500.);
  hptbfinal = new TH1F("hptbfinal","pt b jets passing 1 emerging",500,0.,1500.);
  hptgfinal = new TH1F("hptgfinal","pt g jets passing 1 emerging",500,0.,1500.);
  hptgbbfinal = new TH1F("hptgbbfinal","pt gbb jets 1 emerging",500,0.,1500.);

  hptallfinal2 = new TH1F("hptallfinal2","pt all jets passing 2 emerging",500,0.,1500.);
  hptudfinal2 = new TH1F("hptudfinal2","pt ud jets passing 2 emerging",500,0.,1500.);
  hptsfinal2 = new TH1F("hptsfinal2","pt s jets passing 2 emerging",500,0.,1500.);
  hptcfinal2 = new TH1F("hptcfinal2","pt c jets passing 2 emerging",500,0.,1500.);
  hptbfinal2 = new TH1F("hptbfinal2","pt b jets passing 2 emerging",500,0.,1500.);
  hptgfinal2 = new TH1F("hptgfinal2","pt g jets passing 2 emerging",500,0.,1500.);
  hptgbbfinal2 = new TH1F("hptgbbfinal2","pt gbb jets passing 2 emerging",500,0.,1500.);

  hptallfinale = new TH1F("hptallfinale","pt allemerging jets passing 1 emerging",500,0.,1500.);
  hptudfinale = new TH1F("hptudfinale","pt ud emerging jets passing 1 emerging",500,0.,1500.);
  hptsfinale = new TH1F("hptsfinale","pt s emerging jets passing 1 emerging",500,0.,1500.);
  hptcfinale = new TH1F("hptcfinale","pt c emerging jets passing 1 emerging",500,0.,1500.);
  hptbfinale = new TH1F("hptbfinale","pt b emerging jets passing 1 emerging",500,0.,1500.);
  hptgfinale = new TH1F("hptgfinale","pt g emerging jets passing 1 emerging",500,0.,1500.);
  hptgbbfinale = new TH1F("hptgbbfinale","pt gbb emerging jets passing 1 emerging",500,0.,1500.);


  //2d
  aMip = new TH2F("aMip"," alpha Max versus max IP n-1 plot",100,0.,1.,100,0.,10.);
  haMvjpt = new TH2F("haMvjpt"," alpha Max versus jet pT ",100,0.,1.,100,0.,700.);
  haMvHT = new TH2F("haMvHT"," alpha Max versus HT ",100,0.,1.,100,0.,2500.);
  haMvnvtx = new TH2F("haMvnvtx"," alpha Max versus nvtx ",40,0.,1.,100,0.,40.);

  aMbh = new TH2F("aMbh"," alpha Max versus alphaMax by hand",100,0.,1.2,100,0.,1.2);
  aMbh2D = new TH2F("aMbh2D"," alpha2D versus alphaMax by hand",100,0.,1.2,100,0.,1.2);
  aMbh2Dd = new TH2F("aMbh2Dd"," alpha2D versus alphaMax by hand down quarks",100,0.,1.2,100,0.,1.2);
  aMbh2Ddk = new TH2F("aMbh2Ddk"," alpha2D versus alphaMax by hand dark quarks",100,0.,1.2,100,0.,1.2);
  aMbh2Daem = new TH2F("aMbh2Daem"," alpha2D versus alphaMax by hand failling almost emerging",100,0.,1.2,100,0.,1.2);
  aMmzd = new TH2F("aMmzd"," meanz-pv versus alphaMax by hand down quarks",100,0.,1.2,100,0.,3.0);
  aMmzdk = new TH2F("aMmzdk"," manz-pv versus alphaMax by hand dark quarks",100,0.,1.2,100,0.,3.);


  adkwvd0 = new TH2F("adkwvd0","weight versus ip dark quark jets",100,-1.2,1.2,100,0.,6.);
  adwvd0 = new TH2F("adwvd0","weight versus ip down quark jets",100,-1.2,1.2,100,0.,6.);
  adkwviz = new TH2F("adkwviz","weight versus 3Dip dark quark jets",100,-1.2,1.2,100,0.,6.);
  adwviz = new TH2F("adwviz","weight versus 3Dip down quark jets",100,-1.2,1.2,100,0.,6.);
  adk2Dr0 = new TH2F("adk2Dr0"," 2dIP reco vs 2D matched gen part creation pont tracks dark jets",100,0.,2.,100,0.,0.4);
  ad2Dr0 = new TH2F("ad2Dr0"," 2dIP reco vs 2D matched gen part creation pont tracks down jets",100,0.,2.,100,0.,0.4);
  hdkipphi = new TH2F("hdkipphi","2Dip v phi dark quarks",100,-3.2,3.2,100,0.,0.4);
  hdipphi = new TH2F("hdipphi","2Dip v phi down quarks",100,-3.2,3.2,100,0.,0.4);


  }

  //read all entries and fill the histograms
  Int_t nentries = (Int_t)tt->GetEntries();


  // loop over events
  for (Int_t i=0; i<nentries; i++) {
 
    if(!hasPre) eventCountPreTrigger->Fill(1.5); 
    
    if(otfile) count->Fill("All",1);  // count number of events
    if(otfile) acount->Fill(0.5);
    tt->GetEntry(i);




    if(iDBG>2) std::cout<<"***run event lumi "<<run<<" "<<event<<" "<<lumi<<std::endl;

    if(iDBG>2) {
      std::cout<<" number of vertex is "<<nVtx<<std::endl;
      std::cout<<"pv position is "<<pv_x<<","<<pv_y<<","<<pv_z<<std::endl;
    }

    // make some basic plots on all events before any selections




    // gen particles
    // especially find the first dark quark and dark anti quark
    // assume the following particle is d or dbar
    int firstdkq=0;
    int firstadkq=0;
    int firstdq=0;
    int firstadq=0;

    std::vector<int> bigbs;
    std::vector<int> ts;

    int NNNgp = (*gp_index).size();
    if(iDBG>2) std::cout<<" gen particle id pt eta phi"<<std::endl;
    for(Int_t j=1; j<NNNgp-1; j++) {
      //	if(iDBG>2) std::cout<<"    "<<(*gp_pdgId)[j]<<" "<<(*gp_pt)[j]<<" "<<(*gp_eta)[j]<<" "<<(*gp_phi)[j]<<std::endl;

      // for background, find high pt b's
      if(abs(gp_pdgId->at(j))==5) {
	if(gp_pt->at(j)>50) {
	  if(fabs(gp_eta->at(j))<4) {
	  if(int(bigbs.size())==0) {
	      bigbs.push_back(j);
	    } else {
	      int anewone=0;
	      for(int k=0;k<int(bigbs.size());k++ ) {
	        float ggg = DeltaR(gp_eta->at(j),gp_phi->at(j),gp_eta->at(bigbs[k]),gp_phi->at(bigbs[k]));
	        if(ggg<0.4) {
		  anewone=1;
	        }
	      }
	      if(anewone==0) bigbs.push_back(j);
	    }
          if(iDBG>2) std::cout<<" BIG B   "<<(*gp_pdgId)[j]<<" "<<(*gp_pt)[j]<<" "<<(*gp_eta)[j]<<" "<<(*gp_phi)[j]<<" current size is "<<int(bigbs.size())<<std::endl;

	  }}
      }

      // find ts
      if(abs(gp_pdgId->at(j))==6) {
        if(int(ts.size())==0) {
	  ts.push_back(j);
	} else {
	  int anewone=0;
	  for(int k=0;k<int(ts.size());k++ ) {
	    float ggg = DeltaR(gp_eta->at(j),gp_phi->at(j),gp_eta->at(ts[k]),gp_phi->at(ts[k]));
	    if(ggg<0.4) {
		  anewone=1;
	    }
	  }
	  if(anewone==0) ts.push_back(j);
	}
          if(iDBG>2) std::cout<<" top   "<<(*gp_pdgId)[j]<<" "<<(*gp_pt)[j]<<" "<<(*gp_eta)[j]<<" "<<(*gp_phi)[j]<<" current size is "<<int(ts.size())<<std::endl;

      }
      


      // for signal, find the daughters
      if(((*gp_pdgId)[j]==4900101)&&(firstdkq==0)
           &&( ((*gp_pdgId)[j+1]==1)||((*gp_pdgId)[j-1]==1)) ) {
	firstdkq=j;
	firstdq=j+1;
	if((*gp_pdgId)[j+1]!=1) firstdq=j-1;
	if(iDBG>2) std::cout<<"    match "<<(*gp_pdgId)[firstdkq]<<" "<<(*gp_pt)[firstdkq]<<" "<<(*gp_eta)[firstdkq]<<" "<<(*gp_phi)[firstdkq]<<std::endl;
	if(iDBG>2) std::cout<<"    match "<<(*gp_pdgId)[firstdq]<<" "<<(*gp_pt)[firstdq]<<" "<<(*gp_eta)[firstdq]<<" "<<(*gp_phi)[firstdq]<<std::endl;
      }
      if(((*gp_pdgId)[j]==-4900101)&&(firstadkq==0)
	 &&( ((*gp_pdgId)[j+1]==-1)||((*gp_pdgId)[j-1]==-1)) ) {
	firstadkq=j;
	firstadq=j+1;
	if((*gp_pdgId)[j+1]!=-1) firstadq=j-1;
	if(iDBG>2) std::cout<<"    match "<<(*gp_pdgId)[firstadkq]<<" "<<(*gp_pt)[firstadkq]<<" "<<(*gp_eta)[firstadkq]<<" "<<(*gp_phi)[firstadkq]<<std::endl;
	if(iDBG>2) std::cout<<"    match "<<(*gp_pdgId)[firstadq]<<" "<<(*gp_pt)[firstadq]<<" "<<(*gp_eta)[firstadq]<<" "<<(*gp_phi)[firstadq]<<std::endl;

      }
    }
    if(iDBG>2) {std::cout<<std::endl<<std::endl;
    if(firstdq==0) std::cout<<" first dark quark not found"<<std::endl;
    if(firstdq==0) std::cout<<" first down quark not found"<<std::endl;
    if(firstdq==0) std::cout<<" first anti dark quark not found"<<std::endl;
    if(firstdq==0) std::cout<<" first anti down quark not found"<<std::endl;
}



    // jets
    vector<int> jet_ntrkpt1((*jet_index).size());
    vector<int> jet_ntrkpt1zm((*jet_index).size());
    vector<float> jet_meanip((*jet_index).size());
    vector<double> jet_fpt((*jet_index).size());
    vector<double> jet_ptmax((*jet_index).size());
    vector<double> jet_fnpile((*jet_index).size());
    vector<float> AM((*jet_index).size());
    vector<float> r0((*jet_index).size());
    vector<float> r1((*jet_index).size());
    vector<float> rmed((*jet_index).size());
    vector<int> jntrack((*jet_index).size());
    vector<int> jntrackip((*jet_index).size());
    vector<float> jet_e((*jet_index).size());
    vector<float> jet_theta((*jet_index).size());
    vector<float> jet_px((*jet_index).size());
    vector<float> jet_py((*jet_index).size());
    vector<float> jet_pz((*jet_index).size());
    vector<float> amaxbyhand((*jet_index).size());
    vector<float> amax2D((*jet_index).size());
    vector<float> amax2Df((*jet_index).size());
    vector<float> amax2Df2((*jet_index).size());
    vector<float> jet_meanz((*jet_index).size());
    vector<int> jet_pid_maxEt((*jet_index).size());
    vector<float> jet_maxET_part((*jet_index).size());

    if(otfile) hnjet->Fill((*jet_index).size()+0.5);
    int NNNjet = (*jet_index).size();
    if(iDBG>2) std::cout<<std::endl<<" number of jets is "<<NNNjet<<std::endl;

    for(Int_t j=0; j<NNNjet; j++) {
      if(iDBG>2) std::cout<<"jet j = "<<j<<std::endl;
      jet_theta[j]=2.*atan(exp(-jet_eta->at(j)));
      jet_e[j]=(*jet_pt)[j]/sin(jet_theta[j]);
      jet_px[j]=(*jet_pt)[j]*cos(jet_phi->at(j));
      jet_py[j]=(*jet_pt)[j]*sin(jet_phi->at(j));
      jet_pz[j]=(*jet_pt)[j]/tan(jet_theta[j]);
				
      if(otfile) hpt->Fill(jet_pt->at(j));
      if(otfile) heta->Fill(jet_eta->at(j));
      if(otfile) hjetchf->Fill(jet_chf->at(j));
      if(otfile) if(j<4) heta2->Fill(jet_eta->at(j));



      //      calculate  track variable associated with jet
      jet_ntrkpt1[j]=0;
      jet_ntrkpt1zm[j]=0;
      AM[j]=0;
      amax2D[j]=0.;
      amax2Df2[j]=0.;
      amaxbyhand[j]=0.;
      jet_meanip[j]=0.;
      jet_fpt[j]=0.;
      jet_ptmax[j]=0.;
      jet_fnpile[j]=0.;
      if(r0.size()>0) r0[j]=0.;
      if(r1.size()>0) r1[j]=0.;
      vector<float> track_pts = track_pt->at(j);
      vector<float> track_etas = track_eta->at(j);
      vector<float> track_phis = track_phi->at(j);
      vector<float> track_pvWeights = track_pvWeight->at(j);
      vector<int> track_sources = track_source->at(j);
      vector<int> track_qualitys = track_quality->at(j);
      vector<float> track_ipXYs = track_ipXY->at(j);
      vector<float> track_ipZs = track_ipZ->at(j);
      vector<float> track_ipXYSigs = track_ipXYSig->at(j);
      vector<float> sort_ip;
      vector<float> track_ref_xs = track_ref_x->at(j);
      vector<float> track_ref_ys = track_ref_y->at(j);
      vector<float> track_ref_zs = track_ref_z->at(j);
      jntrack[j]=0;
      jntrackip[j]=0;
      jet_meanz[j]=0.;
      if(iDBG>2) std::cout<<"  with tracks "<<std::endl;
      if(iDBG>2) std::cout<<" #     pt     eta   phi    weight  ipxy    ipxysig     "<<std::endl;


      double sumpt=0.;
      double sumpile=0.;
      double sumptallf=0.;
      double sumallf=0.;
      double sumptall=0.;
      double sumptallnz=0.;
      double sumpt2D=0.;
      double sumpt2Df=0.;
      double sum2Df=0.;
      float tracks_srczero = 0.; // for counting number of tracks src 0
      float tracksFz=0.;
      int iptmaxtrk=0;
      float ptmaxtrk=0.;
      vector<float> forzs;
      if(iDBG>2) std::cout<<" for jet "<<j<<std::endl;
      for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
	if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)) {
	  sumptallnz+=track_pts[itrack];
	  if (fabs(pv_z-track_ref_zs[itrack])<pilecut) {  // effectively turned off due to large cut value
	    tracks_srczero += 1.0;
	    if(track_pts[itrack]>ptmaxtrk) {
	      ptmaxtrk=track_pts[itrack];
	      iptmaxtrk=itrack;
	    }
	    if(iDBG>2) {
	      std::cout<<"  "<<itrack<<" "<<track_pts[itrack]<<" "<<track_etas[itrack]<<" "<<track_phis[itrack]<<" "<<track_pvWeights[itrack]<<" "<<track_ipXYs[itrack]<<" "<<track_ipZs[itrack]<<std::endl;
	    }

	    if(fabs(track_ipXYs[itrack])<0.08) {
	      jntrackip[j]++;
	      forzs.push_back(track_ref_zs[itrack]);
	    }
	    sort_ip.push_back(fabs(track_ipXYs[itrack]));
	    sumptall+=track_pts[itrack];
	    sumptallf+=track_pts[itrack];
	    sumallf+=1.;
	    if(fabs(track_ipXYSigs[itrack])<4) sumpt2Df+=track_pts[itrack];
	    if(fabs(track_ipXYSigs[itrack])<2) sum2Df+=1.;
	    if(fabs(pv_z-track_ref_zs[itrack])<pilecut2) sumpile+=track_pts[itrack];
 	    if(track_pvWeights[itrack]>0) sumpt+=track_pts[itrack];
	    if(fabs(track_ipXYs[itrack])<0.08) sumpt2D+=track_pts[itrack];
	    if(otfile) htvw->Fill(track_pvWeights[itrack]);
	    if(track_pts[itrack]>1) {
	      jet_ntrkpt1[j]+=1;
	      if(fabs(track_ref_zs[itrack]-pv_z)<5.) {
	        jet_ntrkpt1zm[j]+=1;
	      }
	    }
	    jet_meanip[j]=jet_meanip[j]+fabs(track_ipXYs[itrack]);
	    jntrack[j]++;
	    if(iDBG>2) {
	      std::cout
              <<itrack
              <<std::setw(8)<<std::setprecision(3)<<track_pts[itrack]
              <<std::setw(8)<<std::setprecision(3)<<track_etas[itrack]
              <<std::setw(8)<<std::setprecision(3)<<track_phis[itrack]
              <<std::setw(8)<<std::setprecision(3)<<track_pvWeights[itrack]
              <<std::setw(9)<<std::setprecision(3)<<track_ipXYs[itrack]
              <<std::setw(8)<<std::setprecision(3)<<track_ipXYSigs[itrack]
		     <<std::endl;
	    }
	  }  //pileupcut
	} //source and quality
      }
      if(sumptall>0) AM[j]=sumpt/sumptall;
      if(sumptallnz>0) jet_fnpile[j]=sumpile/sumptallnz;
      jet_fpt[j]=ptmaxtrk/jet_pt->at(j);
      jet_ptmax[j]=ptmaxtrk;
      if(sumptall>0) amaxbyhand[j]=sumpt/sumptall;
      if(sumptall>0) amax2D[j]=sumpt2D/sumptall;
      if(sumptallf>0) amax2Df[j]=sumpt2Df/sumptallf;
      if(sumallf>0) amax2Df2[j]=sum2Df/sumallf;
      if(otfile) halpha->Fill(AM[j]);
      //float atmp = jntrack[j];
      if(jntrack[j]>0) jet_meanip[j]=jet_meanip[j]/tracks_srczero;

      //float atmp2 = jntrackip[j];
      //if(tracksFz>0) jet_meanz[j]=jet_meanz[j]/tracksFz;
      int itmp = forzs.size();
      if(itmp>0) {
	std::sort(forzs.begin(),forzs.end());
	int itmp2=itmp/2;
	jet_meanz[j]=forzs[itmp2];
      }

      std::sort(sort_ip.begin(), sort_ip.end());
      std::reverse(sort_ip.begin(),sort_ip.end());
      if(sort_ip.size()>0) r0[j]=sort_ip[0];
      if(sort_ip.size()>1) r1[j]=sort_ip[1];
      if(sort_ip.size()>0)
	{
	  int thesize = sort_ip.size();
	  if (thesize % 2 == 0)
	    {
	      rmed[j] = (sort_ip[thesize/2]+sort_ip[thesize/2 - 1])/2.;
	    }
	  else
	    {
	      rmed[j] = (sort_ip[(thesize)/2]);
	    }
	}


      // recalculate jetmeanz throwing out outlyers
      /*
      float atmp = jet_meanz[j];
      if(iDBG>0) std::cout<<"atmp is "<<atmp<<std::endl;
      jet_meanz[j]=0.;
      tracksFz=0.;
      for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
	if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)) {
	  if(fabs(track_ref_zs[itrack]-atmp)<5) {
	  if(fabs(track_ipXYs[itrack])<0.08) {
	    //jet_meanz[j]+=(track_pts[itrack])*track_ref_zs[itrack];
	    //tracksFz+=track_pts[itrack];
	      jet_meanz[j]+=track_ref_zs[itrack];
	      tracksFz+=1;
	      if(iDBG>2) std::cout<<"itrack meanz tracksFz "<<itrack<<" "<<jet_meanz[j]<<" "<<tracksFz<<std::endl;
	  }
	}
	}
      }
      if(tracksFz>0) jet_meanz[j]=jet_meanz[j]/tracksFz;
      */

      if(iDBG>2) {
	std::cout<<"mean max are "<<jet_meanip[j]<<" "<<r0[j]<<std::endl;
	std::cout<<"   jet "<<j<<" "<<jet_pt->at(j)<<" "<<jet_eta->at(j)<<" "<<jet_phi->at(j)<<" "<<AM[j]<<std::endl;
      }
      if(iDBG>2) std::cout<<" pt eta phi alphamax ntrack r0 AM AM2D AM2Df"<<std::endl;
      if(iDBG>2) {
	std::cout<<"   jet "<<j<<" "<<jet_pt->at(j)<<" "<<jet_eta->at(j)<<" "<<jet_phi->at(j)<<" "<<AM[j]<<" "<<r0[j]<<" "<<AM[j]<<" "<<amax2D[j]<<" "<<amax2Df[j]<<std::endl;
      }

      // calculate some gen particle information for jet
      int NNNgp = (*gp_index).size();
      int igenmax=-1;
      float etgenmax=0.;
      for(Int_t igen=1; igen<NNNgp; igen++) {
        if((abs(gp_pdgId->at(igen))<6)||(abs(gp_pdgId->at(igen))==21)) {  // quark or gluon
	  if(DeltaR(jet_eta->at(j),jet_phi->at(j),gp_eta->at(igen),gp_phi->at(igen))<0.4) {
	    if(gp_pt->at(igen)>etgenmax) {
	      igenmax=igen;
	      etgenmax=gp_pt->at(igen);
	    }
	  }
	}
      }
      // fix glue to bbbar
      float igenmax2=-1;
      float etgenmax2=0.;
      if(igenmax>0) {
	if(abs(gp_pdgId->at(igenmax)==21)) {
          for(Int_t igen=1; igen<NNNgp; igen++) {
            if((abs(gp_pdgId->at(igen))==5)&&(gp_pt->at(igen)>10.)) {  // b
	      if(DeltaR(jet_eta->at(j),jet_phi->at(j),gp_eta->at(igen),gp_phi->at(igen))<0.4) {
	        if(gp_pt->at(igen)>etgenmax2) {
	          igenmax2=1;
	          etgenmax2=gp_pt->at(igen);
	        }
	      }
	    }
	  }
	}
      }

      jet_pid_maxEt[j]=0;
      jet_maxET_part[j]=0;
      if(igenmax>-1) {
	int ipid = gp_pdgId->at(igenmax);
	if(abs(ipid)<6) {
	  jet_pid_maxEt[j]=gp_pdgId->at(igenmax);
	  jet_maxET_part[j] = etgenmax;
	} else {
	  if(igenmax2==-1) {
	    jet_pid_maxEt[j]=7;
	    jet_maxET_part[j] = etgenmax;
	  } else {
	    jet_pid_maxEt[j]=8;
	    jet_maxET_part[j] = etgenmax;

	  }
	}
      }



     }  // end of loop over jets



      //now see which jets are emerging
    if(iDBG>2) std::cout<<" in event "<<event<<" number of jets is "<<NNNjet<<std::endl;
    vector<bool> emerging(NNNjet);
    vector<bool> almostemerging(NNNjet);
    vector<bool> almostemerging2(NNNjet);
    vector<bool> basicjet(NNNjet);
      for( int i=0;i<4;i++) {
	  emerging[i]=false;
	  almostemerging[i]=false;
	  almostemerging2[i]=false;
	  basicjet[i]=false;
	}
      int nbasicjet=0.;
      int nemerging=0;
      int nalmostemerging=0;
      int nalmostemerging2=0;
      for(int ij=0;ij<NNNjet;ij++) {
	
        vector<float> track_ipXYs = track_ipXY->at(ij);
        vector<float> track_ipXYSigs = track_ipXYSig->at(ij);
        vector<int> track_sources = track_source->at(ij);
        vector<int> track_qualitys = track_quality->at(ij);
      vector<float> track_pvWeights = track_pvWeight->at(ij);
      vector<float> track_ref_zs = track_ref_z->at(ij);
	if(otfile) hjetcut->Fill(0.5);

	if(fabs(jet_eta->at(ij))<jetacut) { // jet eta cut
	    if(otfile) hjetcut->Fill(1.5);

	    if(otfile) hbcut_nef->Fill(jet_nef->at(ij));
	    if(jet_nef->at(ij)<NemfracCut) {  // neutral fraction
	      if(otfile) hacut_nef->Fill(jet_nef->at(ij));
	    if(otfile) hjetcut->Fill(2.5);

	    if(otfile) hbcut_ntrkpt1->Fill(jet_ntrkpt1[ij]);
	    if(jet_ntrkpt1[ij]>ntrk1cut) {  // tracks pt>1
	      if(otfile) hacut_ntrkpt1->Fill(jet_ntrkpt1[ij]);
	      if(otfile) hjetcut->Fill(3.5);

	      if(otfile) hbcut_cef->Fill(jet_cef->at(ij));
	      if(jet_cef->at(ij)<CemfracCut) {  //charged fraction
	        if(otfile) hacut_cef->Fill(jet_cef->at(ij));
	        if(otfile) hjetcut->Fill(4.5);

		if(jet_fpt[ij]<0.6) {
	        if(otfile) hjetcut->Fill(5.5);

		//if(jet_fnpile[ij]>-1.) {
		if(jet_fnpile[ij]>0.4) {

		  if(jet_ptmax[ij]<10000) {

	 	    basicjet[ij]=true;
		    if(ij<4) nbasicjet+=1;


	            if(otfile) hbcut_alphamax->Fill(AM[ij]);
		    if(AM[ij]<alphaMaxcut) { // alpha max

	              if(otfile) hacut_alphamax->Fill(AM[ij]);
	              if(otfile) hjetcut->Fill(6.5);
		      almostemerging[ij]=true;
		      if(ij<4) nalmostemerging=nalmostemerging+1;
		      if(iDBG>2) {
		        if(ij<4) {
		          std::cout<<" an almost emerging jet "<<ij<<std::endl;
		          std::cout<<" with r0 of "<<r0[ij]<<std::endl;
		          std::cout<<" and pt of "<<jet_pt->at(ij)<<std::endl;
		        }
		      }

		    }

		    if(amax2Df[ij]<0.3) {
		    if(amax2Df2[ij]<0.3) {
		      almostemerging2[ij]=true;
		      if(ij<4) nalmostemerging2=nalmostemerging2+1;


	              if(otfile) hbcut_maxip->Fill(r0[ij]);
		      if(rmed[ij]>maxIPcut) { // max IP cut
                        if(otfile) hjetcut->Fill(7.5);
	                if(otfile) hbcut_theta2d->Fill(jet_theta2D->at(ij));
		        if(jet_theta2D->at(ij)>Dtheta2dcut) {
                          if(otfile) hjetcut->Fill(8.5);

	                  emerging[ij]=true;
	                  if(ij<4) nemerging+=1.;
		          if(iDBG>2) {
		            if(ij<4) {
		              std::cout<<" an emerging jet "<<ij<<std::endl;
		              std::cout<<" with r0 of "<<r0[ij]<<std::endl;
		              std::cout<<" and pt of "<<jet_pt->at(ij)<<std::endl;
		            }
		          }
		// look at tracks in the emerging jets
		          if(otfile) hmaxipXYEJ->Fill(r0[ij]);
		          if(otfile) hmeanipXYEJ->Fill(jet_meanip[ij]);
		          if(jet_meanip[ij]>r0[ij]) std::cout<<"DANGER DANGER"<<std::endl;
                          for (unsigned itrack=0; itrack<track_ipXYs.size(); itrack++) {
	                    if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
		              if(otfile) hipXYEJ->Fill(track_ipXYs[itrack]);
		              if(otfile) hipXYSigEJ->Fill(track_ipXYSigs[itrack]);
		              if(otfile) htvwEJ->Fill(track_pvWeights[itrack]);
			    }
			  }  // 
			} //theta 2D
		      }//mean ip
		    }} //alpha
		    }}  //end of basic jet selection
		}
	      }
	    }
          }
        }
	if(!emerging[ij]) {
	  if(otfile) hmaxipXYnEJ->Fill(r0[ij]);
	  if(otfile) hmeanipXYnEJ->Fill(jet_meanip[ij]);
                for (unsigned itrack=0; itrack<track_ipXYs.size(); itrack++) {
	          if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
		    if(otfile) hipXYnEJ->Fill(track_ipXYs[itrack]);
		    if(otfile) hipXYSignEJ->Fill(track_ipXYSigs[itrack]);
	           }
                }

	}
	if(iDBG>2) std::cout<<"event pt alphaM cef nef ntrkpt1 r0 emerging  almost almost2"<<event<<" "<<jet_pt->at(ij)<<" "<<AM[ij]<<" "<<jet_cef->at(ij)<<" "<<jet_nef->at(ij)<<" "<<jet_ntrkpt1[ij]<<" "<<r0[ij]<<" "<<emerging[ij]<<" "<<almostemerging[ij]<<" "<<almostemerging2[ij]<<std::endl;
      }
      if(otfile) h_nemg->Fill(nemerging);





      // *************************************************************
    // now start the event selections
      // *************************************************************

      //vertex cuts

      bool PVPT0=true;
      if(pv_indexInColl!=0) PVPT0=false;


      bool PVZ=true;
      if(fabs(pv_z)>20) PVZ=false;

    // require at least 4 jets
    bool C4jet=true;
    if(nbasicjet<4) C4jet=false;
    // HT
    //    double HT = jet_pt->at(0)+jet_pt->at(1)+jet_pt->at(2)+jet_pt->at(3);
    double HT=0.;
    for(int i=0;i<std::min(NNNjet,4);i++) {
      HT+=jet_pt->at(i);
    }


    if(otfile) H_T->Fill(HT);
    if(otfile&&NNNjet>0) hpt1->Fill(jet_pt->at(0));
    if(otfile&&NNNjet>1) hpt2->Fill(jet_pt->at(1));
    if(otfile&&NNNjet>2) hpt3->Fill(jet_pt->at(2));
    if(otfile&&NNNjet>3) hpt4->Fill(jet_pt->at(3));
    bool CHT=true;
    if(HT<HTcut) CHT=false;
    // jet pt
    bool Cpt1=false;
    bool Cpt2=false;
    bool Cpt3=false;
    bool Cpt4=false;
    if(NNNjet>0) {
      if((jet_pt->at(0)>pt1cut)&&(fabs(jet_eta->at(0))<jetacut)) Cpt1=true;}
    if(NNNjet>1) {
      if((jet_pt->at(1)>pt2cut)&&(fabs(jet_eta->at(1))<jetacut)) Cpt2=true;}
    if(NNNjet>2) {
      if((jet_pt->at(2)>pt3cut)&&(fabs(jet_eta->at(2))<jetacut)) Cpt3=true;}
    if(NNNjet>3) {
      if((jet_pt->at(3)>pt4cut)&&(fabs(jet_eta->at(3))<jetacut)) Cpt4=true;}
    // number emerging jets
    bool Cnem = true;
    if(nemerging<NemergingCut) Cnem=false;

    // almost emerging
    bool Canem =true;
    if(nalmostemerging>=4) Canem=false;
    
     
     double amass=-1;
     if(NNNjet>3) {
       int ie1 =-1;
       int ie2=-1;
       int id1=-1;
       int id2=-1;

       for(int i5=0;i5<4;i5++) {
	 if(emerging[i5]) {
	   if(ie1==-1) {ie1=i5;}
	   else {ie2=i5;}
	 } else {
	   if(id1==-1) {id1=i5;}
	   else {id2=i5;}
	 }
       }
       if(iDBG>2) {
	 std::cout<<"ie1 ie2 id1 id2 are "<<ie1<<" "<<ie2<<" "<<id1<<" "<<id2<<std::endl;
       }
       if(ie1>-1&&ie2>-1&&id1>-1&&id2>-1) {
	      float mass1 = sqrt(
				 pow((jet_e[ie1]+jet_e[id1]),2) -
				 pow((jet_px[ie1]+jet_px[id1]),2) -
				 pow((jet_py[ie1]+jet_py[id1]),2) -
				 pow((jet_pz[ie1]+jet_pz[id1]),2)
				 );
	      float mass2 = sqrt(
				 pow((jet_e[ie2]+jet_e[id2]),2) -
				 pow((jet_px[ie2]+jet_px[id2]),2) -
				 pow((jet_py[ie2]+jet_py[id2]),2) -
				 pow((jet_pz[ie2]+jet_pz[id2]),2)
				 );
	      float mass3 = sqrt(
				 pow((jet_e[ie1]+jet_e[id2]),2) -
				 pow((jet_px[ie1]+jet_px[id2]),2) -
				 pow((jet_py[ie1]+jet_py[id2]),2) -
				 pow((jet_pz[ie1]+jet_pz[id2]),2)
				 );
	      float mass4 = sqrt(
				 pow((jet_e[ie2]+jet_e[id1]),2) -
				 pow((jet_px[ie2]+jet_px[id1]),2) -
				 pow((jet_py[ie2]+jet_py[id1]),2) -
				 pow((jet_pz[ie2]+jet_pz[id1]),2)
				 );
	      if(fabs(mass1-mass2)<fabs(mass3-mass4)) {
                amass=(mass1+mass2)/2.;
	      } else {
                amass=(mass3+mass4)/2.;
	      }
	      if(iDBG>2) std::cout<<"mass1 mass2 mass3 mass4 amass "<<mass1<<" "<<mass2<<" "<<mass3<<" "<<mass4<<" "<<amass<<std::endl;
       }
     }

    bool Cmass = false;
    if(fabs(amass-Dmass)<Dmasscut) Cmass=true;

    bool Cmet = false;
    if(met_pt>Dmetcut) Cmet = true;


    //blind
    if(blind) {
      Cnem=false;
      Canem=false;
    }

    // do some plots
    if(otfile) {

      // kine only plots
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4) {
	hHTko->Fill(HT);
	hpt1ko->Fill(jet_pt->at(0));
	hpt2ko->Fill(jet_pt->at(1));
	hpt3ko->Fill(jet_pt->at(2));
	hpt4ko->Fill(jet_pt->at(3));

      }

      // jet plots
      vector<bool> matchdkq(NNNjet);;
      vector<bool> matchdq(NNNjet);
      float dr;
      for(int i=0;i<NNNjet;i++) {
	
        vector<float> track_pts = track_pt->at(i);
        vector<float> track_etas = track_eta->at(i);
        vector<float> track_phis = track_phi->at(i);
        vector<float> track_ipXYs = track_ipXY->at(i);
        vector<float> track_ipZs = track_ipZ->at(i);
        vector<float> track_ipXYSigs = track_ipXYSig->at(i);
        vector<int> track_sources = track_source->at(i);
        vector<int> track_qualitys = track_quality->at(i);
        vector<float> track_pvWeights = track_pvWeight->at(i);
        vector<float> track_ref_zs = track_ref_z->at(i);


	
	if(basicjet[i]) {
	  if(jet_pt->at(i)>50 ) {
	    matchdkq[i]=false;
	    matchdq[i]=false;
	    if(firstdkq>0) {
              dr=DeltaR(jet_eta->at(i),jet_phi->at(i),gp_eta->at(firstdkq),gp_phi->at(firstdkq));
	      if(dr<0.4) {
		matchdkq[i]=true;
	        if(iDBG>2) std::cout<<" matched jet "<<i<<" with dark quark dR="<<dr<<std::endl;
	       }
	    }


	    if(firstadkq>0) {
	      dr=DeltaR(jet_eta->at(i),jet_phi->at(i),gp_eta->at(firstadkq),gp_phi->at(firstadkq));
	      if(dr<0.4) {
		matchdkq[i]=true;
	        if(iDBG>2) std::cout<<" matched jet "<<i<<" anti with dark quark dr="<<dr<<std::endl;
	      }
	    }


	    if(firstdq>0) {
	      dr=DeltaR(jet_eta->at(i),jet_phi->at(i),gp_eta->at(firstdq),gp_phi->at(firstdq));
	      if(dr<0.4) {
		matchdq[i]=true;
	      if(iDBG>2) std::cout<<" matched jet "<<i<<" with down quark dr="<<dr<<std::endl;
	      }
	    }


	    if(firstdq>0) {
	      dr=DeltaR(jet_eta->at(i),jet_phi->at(i),gp_eta->at(firstadq),gp_phi->at(firstadq));
	      if(dr<0.4) {
		matchdq[i]=true;
	        if(iDBG>2) std::cout<<" matched jet "<<i<<" with antidown quark dr="<<dr<<std::endl;
	      }
	    }
	    if(iDBG>2) std::cout<<" matchdkq matchdq are "<<matchdkq[i]<<" "<<matchdq[i]<<std::endl;

	    //if(matchdkq[i]&&matchdq[i]) std::cout<<"danger danger match both dark and down quark"<<std::endl;


	    haMgj->Fill(AM[i]);
	    if(iDBG>2) {
	    if(AM[i]<0.015) {
	      std::cout<<"CHECK"<<std::endl;
	      std::cout<<"alpha max is "<<AM[i]<<std::endl;
	      std::cout<<"jet pt is "<<jet_pt->at(i)<<std::endl;  
	      std::cout<<"jet eta is "<<jet_eta->at(i)<<std::endl;  
	      std::cout<<"jet phi is "<<jet_phi->at(i)<<std::endl;  
	      std::cout<<" number tracks in jet is "<<jntrack[i]<<std::endl;
	      std::cout<<" number true interactions is "<<nTrueInt<<std::endl;
	      std::cout<<" total number tracks is "<<nTracks<<std::endl;
	    }
	    }

	    haMvjpt->Fill(AM[i],jet_pt->at(i));
	    haMvHT->Fill(AM[i],HT);
	    haMvnvtx->Fill(AM[i],nVtx);
	    hjptb->Fill(jet_pt->at(i));
	    if(emerging[i]) {
	      hjpta->Fill(jet_pt->at(i));
	    }

	    if(iDBG>2) {
	      std::cout<<" alphamax alphamax by hand alpha2d are "<<AM[i]<<" "<<amaxbyhand[i]<<" "<<amax2D[i]<<std::endl;
	    }
	    aMbh->Fill(AM[i],amaxbyhand[i]);


	    // plots for dark and down quark jets  WILL ROBINSON
	    if(matchdkq[i]&&(!matchdq[i])) {  // dark quark jet
	      hdkjetam->Fill(AM[i]);
	      hsum2Dfdk->Fill(amax2Df2[i]);
	      hdkjetamo->Fill(jet_alphaMax->at(i));
	      ham2dfdk->Fill(amax2Df[i]);
	      hdkjetam2d->Fill(amax2D[i]);
	      aMbh2Ddk->Fill(AM[i],amax2D[i]);
	      float why1=jet_meanz[i]-pv_z;
	      aMmzdk->Fill(AM[i],fabs(why1));
	      if(almostemerging2[i]) {
		hmzamd->Fill(why1);
		h2damd->Fill(amax2D[i]);
	      } else {
		hmznamd->Fill(why1);
		h2dnamd->Fill(amax2D[i]);
	      }
	      hmeanzdk->Fill(why1);
	      hdkjetmeanip->Fill(jet_meanip[i]);
	      hdkjetntr->Fill(jet_ntrkpt1[i]);
	      hdkjetmaxip->Fill(r0[i]);
	      
              for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
	        if((track_sources[itrack]==0)&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
		  hdkjettrkip->Fill(track_ipXYs[itrack]);
		  hdkjettrkips->Fill(track_ipXYSigs[itrack]);
		  hdkjettrkw->Fill(track_pvWeights[itrack]);
		  hdkipphi->Fill(track_phis[itrack],track_ipXYs[itrack]);
		  adkwvd0->Fill(track_pvWeights[itrack],track_ipXYs[itrack]);
		  adkwviz->Fill(track_pvWeights[itrack],track_ipZs[itrack]);
		  //find gen particle that best matches
		  float dR=99999.;
		  int ipnt=0;
                  for(Int_t j=0; j<(*gp_index).size(); j++) {
		    //		    if(iDBG>2) std::cout<<" gen particle "<<j<<" has status charge "<<(*gp_status)[j]<<" "<<(*gp_charge)[j]<<std::endl;
		    if((*gp_status)[j]==1 ) { //stable
		      if((*gp_charge)[j]!=0) {  //charged
                        dr=DeltaR((*gp_eta)[j],(*gp_phi)[j],track_etas[itrack],track_phis[itrack]);
			//			if(iDBG>2) std::cout<<" dr is "<<dr<<std::endl;
			if(dr<dR) {
			  dR=dr;
			  ipnt=j;
			}
		      }
		    }
		  }  // end loop gen part
		  if(iDBG>2) std::cout<<" track "<<itrack<<" matches gen part "<<ipnt<<std::endl;
		  if(ipnt>0) {
		    hdkjettrkdr->Fill(dR);
		    if(dR<0.01) {
		      float aaa =sqrt(
                       (*gp_vx)[ipnt]*(*gp_vx)[ipnt]
		      +(*gp_vy)[ipnt]*(*gp_vy)[ipnt]
		     			   );

		      adk2Dr0->Fill(aaa,track_ipXYs[itrack]);
		      hdkjettrgip->Fill(aaa);
		    }
		  }
		}// end track source
	      }  // end loop over tracks
	    }  // end match dark quark
	   
	    if(matchdq[i]&&(!matchdkq[i])) {  // down quark jet
	      hdjetam->Fill(AM[i]);
	      hsum2Dfd->Fill(amax2Df2[i]);
	      hdjetamo->Fill(jet_alphaMax->at(i));
	      ham2dfd->Fill(amax2Df[i]);
	      hdjetam2d->Fill(amax2D[i]);
	      aMbh2Dd->Fill(AM[i],amax2D[i]);
	      float why1=jet_meanz[i]-pv_z;
	      aMmzd->Fill(AM[i],fabs(why1));
	    hmeanzd->Fill(jet_meanz[i]-pv_z);
	      hdjetmeanip->Fill(jet_meanip[i]);
	      hdjetntr->Fill(jet_ntrkpt1[i]);
	      hdjetmaxip->Fill(r0[i]);
	      
              for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
	        if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
		  hdjettrkip->Fill(track_ipXYs[itrack]);
		  hdjettrkips->Fill(track_ipXYSigs[itrack]);
		  hdjettrkw->Fill(track_pvWeights[itrack]);
		  adwvd0->Fill(track_pvWeights[itrack],track_ipXYs[itrack]);
		  adwviz->Fill(track_pvWeights[itrack],track_ipZs[itrack]);
		  hdipphi->Fill(track_phis[itrack],track_ipXYs[itrack]);

		  //find gen particle that best matches
		  float dR=99999.;
		  int ipnt=0;
                  for(Int_t j=0; j<(*gp_index).size(); j++) {
		    if((*gp_status)[j]==1 ) { //stable
		      if((*gp_charge)[j]!=0) {  //charged
                        dr=DeltaR((*gp_eta)[j],(*gp_phi)[j],track_etas[itrack],track_phis[itrack]);
			if(dr<dR) {
			  dR=dr;
			  ipnt=j;
			}
		      }
		    }
		  }  // end loop gen part
		  if(iDBG>2) std::cout<<" track "<<itrack<<" matches gen part "<<ipnt<<std::endl;

		  if(ipnt>0) {
		    hdjettrkdr->Fill(dR);
		    if(dR<0.01) {
                      float aaa = sqrt(
                       (*gp_vx)[ipnt]*(*gp_vx)[ipnt]
		       +(*gp_vy)[ipnt]*(*gp_vy)[ipnt]);

		      ad2Dr0->Fill(aaa,track_ipXYs[itrack]);
		      hdjettrgip->Fill(aaa);
		    }
		  }

		}  //end track source
	      
	      }  // end loop over tracks
	    }  // if matches down quark
	  }  // end pT 50
	}  // end basic jet
      }

      //N-1 plots
      if(PVZ&&PVPT0&&C4jet&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem&&Cmass&&Cmet) hHTnm1->Fill(HT);
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem&&Cmass&&Cmet) hpt1nm1->Fill(jet_pt->at(0));
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt3&&Cpt4&&Cnem&&Canem&&Cmass&&Cmet) hpt2nm1->Fill(jet_pt->at(1));
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt4&&Cnem&&Canem&&Cmass&&Cmet) hpt3nm1->Fill(jet_pt->at(2));
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cnem&&Canem&&Cmass&&Cmet) hpt4nm1->Fill(jet_pt->at(3));
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem&&Cmass&&Cmet) hnemnm1->Fill(nemerging);
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem&&Cmet) hmassnm1->Fill(amass);
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem&&Cmass) hmetnm1->Fill(met_pt);
      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem&&Cmass&&Cmet)
        {
	  htheta2D1nm1->Fill(log10(jet_theta2D->at(0)));
	  htheta2D2nm1->Fill(log10(jet_theta2D->at(1)));
	  htheta2D3nm1->Fill(log10(jet_theta2D->at(2)));
	  htheta2D4nm1->Fill(log10(jet_theta2D->at(3)));
        }


      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem&&Cmass&&Cmet) {
        for(int i=0;i<4;i++) {
	  if(basicjet[i]) {
	    halphanm1->Fill(AM[i]);
	    aMip->Fill(AM[i],r0[i]);
	    hntrk1nm1->Fill(jet_ntrkpt1[i]);
	    if((AM[i]<alphaMaxcut)) {
	      hmaxipnm1->Fill(r0[i]);

	      if(iDBG>2) {
              std::cout<<" almost emerging"<<std::endl;
	      if(r0[i]<0.05) std::cout<<"DANGER DANGER"<<std::endl;
                std::cout<<" jet pt is "<<jet_pt->at(i)
	    	     <<" ntrkpt1 is "<<jet_ntrkpt1[i]
	    	     <<" meanip is "<<jet_meanip[i]
	    	     <<" ip max is "<<r0[i]
	    	     <<" second largest ip is "<<r1[i]
	    	     <<" alpha max is "<<AM[i]
                <<std::endl;
	      }
              vector<float> track_pts = track_pt->at(i);
              vector<int> track_sources = track_source->at(i);
              vector<int> track_qualitys = track_quality->at(i);
              vector<float> track_ipXYs = track_ipXY->at(i);
              vector<float> track_ipZs = track_ipZ->at(i);
              vector<float> track_ipXYSigs = track_ipXYSig->at(i);
              vector<float> track_pvWeights = track_pvWeight->at(i);
              vector<int> track_nMissInnerHitss = track_nMissInnerHits->at(i);
              vector<int> track_nMissInnerPxlLayerss = track_nMissInnerPxlLayers->at(i);
              vector<int> track_nPxlLayerss = track_nPxlLayers->at(i);
              vector<int> track_nHitss = track_nHits->at(i);
              vector<float> track_ref_zs = track_ref_z->at(i);
              for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
	        if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
		  if(iDBG>2) {
			std::cout<<"    track pt is "<<track_pts[itrack]
			 <<" ipxy is "<<track_ipXYs[itrack]
			 <<" ipZ is "<<track_ipZs[itrack]
			 <<" ipxysig is "<<track_ipXYSigs[itrack]
				 <<" pv weight is "<<track_pvWeights[itrack]
			 <<" missinnerhits is "<<track_nMissInnerHitss[itrack]
			 <<" missinnerpxllayers is "<<track_nMissInnerPxlLayerss[itrack]
			 <<" pxllayers is "<<track_nPxlLayerss[itrack]
			 <<" nHits is "<<track_nHitss[itrack]
			 <<std::endl;
		  }
		  if(otfile) hnHitsnm1->Fill(track_nHitss[itrack]);
	        }
              }
	    }  // alphamax cuut
	  }  //basic jet
	}//loop over jets
      } // select events


      if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4) {
        for(int i=0;i<4;i++) {
	    aMbh2D->Fill(amax2D[i],amaxbyhand[i]);
	    hmeanz->Fill(jet_meanz[i]-pv_z);
        }
      }

      // plots for events that fail almost energing
    if(C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&(!Canem)) {
      for(int i=0;i<4;i++) {
	    aMbh2Daem->Fill(amax2D[i],amaxbyhand[i]);
	    hmeanzfa->Fill(jet_meanz[i]-pv_z);
	    hntrkpt1zmfa->Fill(jet_ntrkpt1zm[i]);
	    h2dfa->Fill(amax2D[i]);
	    if(iDBG>0) {
	      std::cout<<" jet meanz pvz are "<<jet_meanz[i]<<" "<<pv_z<<std::endl;
	      std::cout<<" jet ntrkpt1zm is "<<jet_ntrkpt1zm[i]<<std::endl;
	      std::cout<<"FAIL CANEM"<<std::endl;
	      std::cout<<"pvz pvpt0 are "<<PVZ<<" "<<PVPT0<<std::endl;
	    }
	aMbh2Daem->Fill(amax2D[i],amaxbyhand[i]);
      }

    }  // end plots for events that fail almost emerging

    // similar plots for those that pass almost enmering
    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&(Canem)&&Cmass&&Cmet) {
      for(int i=0;i<4;i++) {
	    hmeanzpa->Fill(jet_meanz[i]-pv_z);
	    hntrkpt1zmpa->Fill(jet_ntrkpt1zm[i]);
	    h2dpa->Fill(amax2D[i]);
	    if(iDBG>1) {
	      std::cout<<" jet meanz pvz are "<<jet_meanz[i]<<" "<<pv_z<<std::endl;
	      if(fabs(jet_meanz[i]-pv_z)>5) std::cout<<"danger"<<std::endl;
	    }
        }
    }

    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&nalmostemerging2>=2) {
      for(int i=0;i<4;i++) {
	if(almostemerging2[i]) {
	  if((AM[i]<alphaMaxcut)) {
	    hnmaxipnm1->Fill(r0[i]);
	  }
	}
      }
    }

    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&nalmostemerging2>=1) {
      for(int i=0;i<4;i++) {
	if(almostemerging2[i]) {
	  if((AM[i]<alphaMaxcut)) {
	    hn2maxipnm1->Fill(r0[i]);
	  }
	}
      }
    }




    // debug spew
    if(iDBG>2) std::cout<<"pvz pvpt0 c4jet cht cpt1 cpt2 cpt3 cpt4 cnem "<<PVZ<<" "<<PVPT0<<" "<<C4jet<<" "<<CHT<<" "<<Cpt1<<" "<<Cpt2<<" "<<Cpt3<<" "<<Cpt4<<" "<<Cnem<<std::endl;

    // preselection plots
    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4) {
      hpvpre->Fill(pv_z);
      hnvtxpre->Fill(nVtx);
      hntrkpre->Fill(nTracks);
      float aab=0.;
      for(int i=0;i<4;i++) {
	hjetptfrpre->Fill(std::min(jet_fpt[i],1.2));
	hptallpre->Fill(jet_pt->at(i));
	hmeanzpre->Fill(jet_meanz[i]-pv_z);
	if(jet_pid_maxEt[i]==1) hptudpre->Fill(jet_pt->at(i));
	if(jet_pid_maxEt[i]==2) hptudpre->Fill(jet_pt->at(i));
	if(jet_pid_maxEt[i]==3) hptspre->Fill(jet_pt->at(i));
	if(jet_pid_maxEt[i]==4) hptcpre->Fill(jet_pt->at(i));
	if(jet_pid_maxEt[i]==5) hptbpre->Fill(jet_pt->at(i));
	if(jet_pid_maxEt[i]==7) hptgpre->Fill(jet_pt->at(i));
	if(jet_pid_maxEt[i]==8) hptgbbpre->Fill(jet_pt->at(i));

	if(jet_pid_maxEt[i]==5) ham2dfb->Fill(amax2Df[i]);
	if(jet_pid_maxEt[i]==8) ham2dfgbb->Fill(amax2Df[i]);
	if(jet_pid_maxEt[i]==7) ham2dfg->Fill(amax2Df[i]);
	if(jet_pid_maxEt[i]==1) ham2dfud->Fill(amax2Df[i]);
	if(jet_pid_maxEt[i]==2) ham2dfud->Fill(amax2Df[i]);

	if(jet_pid_maxEt[i]==5) {
	  if((jet_pt->at(i)>100)&&(jet_pt->at(i)<300)) ham2dfbpt1->Fill(amax2Df[i]);
	  if((jet_pt->at(i)>300)&&(jet_pt->at(i)<600)) ham2dfbpt2->Fill(amax2Df[i]);
	  if((jet_pt->at(i)>600)) ham2dfbpt3->Fill(amax2Df[i]);
	}

	if((jet_pid_maxEt[i]==1)||(jet_pid_maxEt[i]==2)) {
	  if((jet_pt->at(i)>100)&&(jet_pt->at(i)<300)) ham2dfudpt1->Fill(amax2Df[i]);
	  if((jet_pt->at(i)>300)&&(jet_pt->at(i)<600)) ham2dfudpt2->Fill(amax2Df[i]);
	  if((jet_pt->at(i)>600)) ham2dfudpt3->Fill(amax2Df[i]);
	}


	if(emerging[i]) {
	  hptallpree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==1) hptudpree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==2) hptudpree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==3) hptspree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==4) hptcpree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==5) hptbpree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==7) hptgpree->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==8) hptgbbpree->Fill(jet_pt->at(i));
	}

	hsum2Dfpre->Fill(amax2Df2[i]);
	hjntrkpre->Fill(jet_ntrkpt1[i]);
	hfpilepre->Fill(jet_fnpile[i]);
	hptmaxpre->Fill(std::min(jet_ptmax[i],399.5));
        vector<int> track_sources = track_source->at(i);
        vector<int> track_qualitys = track_quality->at(i);
        vector<float> track_ref_zs = track_ref_z->at(i);
        for (unsigned itrack=0; itrack<track_ref_zs.size(); itrack++) {
	  if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
	    hdzpre->Fill(pv_z-track_ref_zs[itrack]);
	  }
	}
	for(int j=i+1;j<4;j++) {
	  if(fabs(jet_meanz[i]-jet_meanz[j])>aab) {
	    aab=fabs(jet_meanz[i]-jet_meanz[j]);
	  }
	} 
      }
      hdzjpre->Fill(aab);

    }  //end preselection plots


    //final selection spew for debug  all cuts except nemerging, separate spew
    // for 1 and 2 emerging
    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem&&Cmass&&Cmet) {
      if(nemerging>0) {  // some debug spew, not a cut

	for(int i=0;i<4;i++) {
	  hptallfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==1) hptudfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==2) hptudfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==3) hptsfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==4) hptcfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==5) hptbfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==7) hptgfinal->Fill(jet_pt->at(i));
	  if(jet_pid_maxEt[i]==8) hptgbbfinal->Fill(jet_pt->at(i));
	  if(emerging[i]) {
	    hptallfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==1) hptudfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==2) hptudfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==3) hptsfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==4) hptcfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==5) hptbfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==7) hptgfinale->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==8) hptgbbfinale->Fill(jet_pt->at(i));
	  }
	}

	if(nemerging>1) {
	  for(int i=0;i<4;i++) {
	    hptallfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==1) hptudfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==2) hptudfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==3) hptsfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==4) hptcfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==5) hptbfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==7) hptgfinal2->Fill(jet_pt->at(i));
	    if(jet_pid_maxEt[i]==8) hptgbbfinal2->Fill(jet_pt->at(i));
	  }
	}

	if(iDBG>0) if(nemerging>1) std::cout<<"HAS "<<nemerging<<"  EMERGING"<<std::endl;

	// see if matches a ba
	for(int i=0;i<4;i++) {
	  if(emerging[i]) {
	    float bdr=1000.;
	    for(int k=0;k<bigbs.size();k++) {
	      float bdt = DeltaR(jet_eta->at(i),jet_phi->at(i),gp_eta->at(bigbs[k]),gp_phi->at(bigbs[k]));
	      if(iDBG>1) std::cout<<"i k bdt are "<<i<<" "<<k<<" "<<bdt<<std::endl;
	      if(bdt<bdr) bdr=bdt;
	    }
	    if(bdr>10) bdr=-1;
	    hbigb->Fill(bdr);
	    if(iDBG>0) {
	      std::cout<<"bdr is "<<bdr<<std::endl;
	      if(abs(bdr)<0.4) std::cout<<" jet "<<i<<" tagged as b"<<std::endl;
	    }
	  }  //end emerging
	}  //end loop over jets



	if(iDBG>0) {
	  if(nemerging>1) std::cout<<"passing2 run lumi event filename is "<<run<<" "<<lumi<<" "<<event<<" "<<inputfilename<<std::endl;
	  else  std::cout<<"passing1 run lumi event filename is "<<run<<" "<<lumi<<" "<<event<<" "<<inputfilename<<std::endl;
	}
	if(iDBG>0) {
	  if(!Canem) std::cout<<"FAILS ALMOST EMERGING"<<std::endl;
	}
	if(iDBG>0) std::cout<<"pv position is "<<pv_x<<","<<pv_y<<","<<pv_z<<std::endl;
	if(iDBG>0) std::cout<<" pv ntracks is "<<nTracks<<std::endl;
	if(iDBG>0) std::cout<<" number of vertices is "<<nVtx<<std::endl;

	if(iDBG>0) std::cout<<"     pt    eta    phi   nef    cfe   ntrkpt1 alphamax    r0    amax2d    amax2df  meanz jet_fpt jet_fnpile  2dipfrac  pid   partet"<<std::endl;
	for(int i=0;i<4;i++) {
	  if(AM[i]<0.002&&iDBG>0) std::cout<<"BAD BAD CAT"<<std::endl; 
	  if(iDBG>0) std::cout
            <<std::setw(8)<<std::setprecision(3)<<jet_pt->at(i)
            <<std::setw(8)<<std::setprecision(3)<<jet_eta->at(i)
            <<std::setw(8)<<std::setprecision(3)<<jet_phi->at(i)
            <<std::setw(8)<<std::setprecision(3)<<jet_nef->at(i)
	    <<std::setw(8)<<std::setprecision(3)<<jet_cef->at(i)
	    <<std::setw(8)<<std::setprecision(3)<<jet_ntrkpt1[i]
	    <<std::setw(8)<<std::setprecision(3)<<AM[i]
	    <<std::setw(8)<<std::setprecision(3)<<r0[i]
	    <<std::setw(8)<<std::setprecision(3)<<amax2D[i]
	    <<std::setw(8)<<std::setprecision(3)<<amax2Df[i]
	    <<std::setw(8)<<std::setprecision(3)<<jet_meanz[i]
	    <<std::setw(8)<<std::setprecision(3)<<jet_fpt[i]
	    <<std::setw(8)<<std::setprecision(3)<<jet_fnpile[i]
	    <<std::setw(8)<<std::setprecision(3)<<amax2Df2[i]
	    <<std::setw(8)<<std::setprecision(3)<<jet_pid_maxEt[i]
	    <<std::setw(8)<<std::setprecision(3)<<jet_maxET_part[i]
	    <<std::endl;
	}  
	if(iDBG>0) {
	  std::cout<<"this event has "<<bigbs.size()<<" big bs"<<std::endl;
	      	      std::cout<<"this event has "<<ts.size()<<" topss"<<std::endl;
	  for(int k=0;k<bigbs.size();k++) {
	    std::cout<<"b pt eta phi "<<gp_pt->at(bigbs[k])<<" "<<gp_eta->at(bigbs[k])<<" "<<gp_phi->at(bigbs[k])<<std::endl;
	  }
	}
	    
	if(iDBG>0) {
	  for(int i=0;i<4;i++) {
	    std::cout<<" for jet "<<i<<std::endl;
            std::cout<<"  with tracks "<<std::endl;
            std::cout<<" #     pt     eta   phi    weight  ipxy    ipxysig  refx    refy    refz   quality  algo nmissinner nmissouter"<<std::endl;
            vector<float> track_pts = track_pt->at(i);
            vector<float> track_etas = track_eta->at(i);
            vector<float> track_phis = track_phi->at(i);
            vector<float> track_pvWeights = track_pvWeight->at(i);
            vector<int> track_sources = track_source->at(i);
            vector<int> track_qualitys = track_quality->at(i);
            vector<float> track_ipXYs = track_ipXY->at(i);
            vector<float> track_ipZs = track_ipZ->at(i);
            vector<float> track_ipXYSigs = track_ipXYSig->at(i);
            vector<float> track_ref_xs = track_ref_x->at(i);
            vector<float> track_ref_ys = track_ref_y->at(i);
            vector<float> track_ref_zs = track_ref_z->at(i);
            vector<int> track_algos = track_algo->at(i);
	    vector<int> track_nMissInnerTrkLayerss = track_nMissInnerTrkLayers->at(i);
	    vector<int> track_nMissOuterTrkLayerss = track_nMissOuterTrkLayers->at(i);

            for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
	      if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
	        std::cout
                <<itrack
                <<std::setw(8)<<std::setprecision(3)<<track_pts[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_etas[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_phis[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_pvWeights[itrack]
                <<std::setw(9)<<std::setprecision(3)<<track_ipXYs[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_ipXYSigs[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_ref_xs[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_ref_ys[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_ref_zs[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_qualitys[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_algos[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_nMissInnerTrkLayerss[itrack]
                <<std::setw(8)<<std::setprecision(3)<<track_nMissOuterTrkLayerss[itrack]
		     <<std::endl;
	      }
	    }// loop over tracks
	  }  // loop over jets
	} // iDBG

	// some plots for events that pass all cuts
	if(nemerging>=NemergingCut) {
	  H_T3->Fill(HT);   
	  hmass->Fill(amass);
	  hpvfinal->Fill(pv_z);
          hnvtxfinal->Fill(nVtx);
          hntrkfinal->Fill(nTracks);
	  float aab=0.;
	  for(int i=0;i<4;i++) {
	    if(emerging[i]) {
	      hmeanzfinal->Fill(jet_meanz[i]-pv_z);
	      hjetptfrfinal->Fill(std::min(jet_fpt[i],1.2));
	      hsum2Dffinal->Fill(amax2Df2[i]);
	      hjntrkfinal->Fill(jet_ntrkpt1[i]);
	      hfpilefinal->Fill(jet_fnpile[i]);
	      hptmaxfinal->Fill(std::min(jet_ptmax[i],399.5));
              vector<int> track_sources = track_source->at(i);
              vector<int> track_qualitys = track_quality->at(i);
              vector<float> track_ref_zs = track_ref_z->at(i);
              for (unsigned itrack=0; itrack<track_ref_zs.size(); itrack++) {
	        if((track_sources[itrack]==0)&&((track_qualitys[itrack]&4)>0)&& (fabs(pv_z-track_ref_zs[itrack])<pilecut)) {
	          hdzfinal->Fill(pv_z-track_ref_zs[itrack]);
	        }
	      }
	    }  // end emerging
	    for(int j=i+1;j<4;j++) {
	      if(fabs(jet_meanz[i]-jet_meanz[j])>aab) {
	        aab=fabs(jet_meanz[i]-jet_meanz[j]);
	      }
	    } 
          } //end loop over jets
          hdzjfinal->Fill(aab);
        if(iDBG>0) std::cout<<"npass  event is "<<npass<<" "<<event<<std::endl;
        if(iDBG>0) std::cout<<"nemerging nalmostemerging almostemerging2 "<<nemerging<<" "<<nalmostemerging<<" "<<nalmostemerging2<<std::endl;

	}  //end nemerging > nemerging cut



      }  // nemerging>0
    }  //selection besides on nemerging

      // make plots for fake rate studes
    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem) {
      for(Int_t j=0; j<NNNjet; j++) {
	if(basicjet[j]) {
	  hjptfrb->Fill(jet_pt->at(j));
	  if(almostemerging2[j]){
	    hjptfra1->Fill(jet_pt->at(j));
	    if(emerging[j]) {
	      hjptfra2->Fill(jet_pt->at(j));
	    }
	  }
	}
      }
    }
      // check without Canem
    if(PVZ&&PVPT0&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4) {
      for(Int_t j=0; j<NNNjet; j++) {
	if(basicjet[j]) {
	  hjptfrbc->Fill(jet_pt->at(j));
	  if(almostemerging2[j]){
	    hjptfra1c->Fill(jet_pt->at(j));
	    if(emerging[j]) {
	      hjptfra2c->Fill(jet_pt->at(j));
	    }
	  }
	}
      }
    }

    }  // close if (otfile)
    // apply cuts sequentially



    if(C4jet) {
    if(otfile) count->Fill("4 jets",1);
    if(otfile) acount->Fill(1.5);

    // calculate HT and require it greater than some cut value
    if(CHT) {
    if(otfile) count->Fill("HT",1);
    if(otfile) acount->Fill(2.5);
    if(otfile) H_T2->Fill(HT);

    // do pT cuts on jets  
    if(Cpt1) {
    if(otfile) count->Fill("jet pt1",1);
    if(otfile) acount->Fill(3.5);


    if(Cpt2) {
    if(otfile) count->Fill("jet pt2",1);
    if(otfile) acount->Fill(4.5);


    if(Cpt3) {
    if(otfile) count->Fill("jet pt3",1);
    if(otfile) acount->Fill(5.5);


    if(Cpt4) {
    if(otfile) count->Fill("jet pt4",1);
    if(otfile) acount->Fill(6.5);

    if(PVPT0) {
    if(otfile) count->Fill("pv 0",1);
    if(otfile) acount->Fill(7.5);


    if(PVZ) {
    if(otfile) count->Fill("pv z",1);
    if(otfile) acount->Fill(8.5);


    if(Cmet) {
    if(otfile) count->Fill("MET",1);
    if(otfile) acount->Fill(9.5);

    if(Cmass) {
    if(otfile) count->Fill("mass",1);
    if(otfile) acount->Fill(10.5);

    if(Canem) {   // almost emerging
    if(otfile) count->Fill("almostemerging",1);
    if(otfile) acount->Fill(11.5);

    if(Cnem) {  // emerging
    if(otfile) count->Fill("emerging",1);
    if(otfile) acount->Fill(12.5);

            npass+=1;

    }}}}}}}}}}}}




  }  // end of loop over events

  if(otfile) {
    TFile myfile(outputfilename,"RECREATE");
    count->LabelsDeflate();
    count->LabelsOption("v");
  //  count->LabelsOption("a");

    eventCountPreTrigger->Write();
    acount->Write();
    count->Write();
    hjetcut->Write();
    hpt->Write();
    hnjet->Write();
    heta->Write();
    heta2->Write();
    halpha->Write();
    haMgj->Write();
    H_T->Write();
    H_T2->Write();
    H_T3->Write();
    H_T4->Write();
    hpt1->Write();
    hpt2->Write();
    hpt3->Write();
    hpt4->Write();
    h_nemg->Write();
    hjetchf->Write();
    hbcut_ntrkpt1->Write();
    hacut_ntrkpt1->Write();
    hbcut_nef->Write();
    hacut_nef->Write();
    hbcut_cef->Write();
    hacut_cef->Write();
    hbcut_alphamax->Write();
    hacut_alphamax->Write();
    hbcut_maxip->Write();
    hbcut_theta2d->Write();
    hHTnm1->Write();
    hmassnm1->Write();
    htheta2D1nm1->Write();
    htheta2D2nm1->Write();
    htheta2D3nm1->Write();
    htheta2D4nm1->Write();
    hmetnm1->Write();
    hpt1nm1->Write();
    hpt2nm1->Write();
    hpt3nm1->Write();
    hpt4nm1->Write();
    halphanm1->Write();
    hmaxipnm1->Write();
    hnmaxipnm1->Write();
    hn2maxipnm1->Write();
    hnHitsnm1->Write();
    hntrk1nm1->Write();
    hnemnm1->Write();
    hipXYEJ->Write();
    hipXYnEJ->Write();
    htvw->Write();
    htvwEJ->Write();
    hipXYSigEJ->Write();
    hipXYSignEJ->Write();
    hmaxipXYEJ->Write();
    hmaxipXYnEJ->Write();
    hmeanipXYEJ->Write();
    hmeanipXYnEJ->Write();
    hjptb->Write();
    hjpta->Write();
    hjptfrb->Write();
    hjptfra1->Write();
    hjptfra2->Write();
    hjptfrbc->Write();
    hjptfra1c->Write();
    hjptfra2c->Write();

    hpt1ko->Write();
    hpt2ko->Write();
    hpt3ko->Write();
    hpt4ko->Write();
    hmass->Write();

    hHTko->Write();

    hdkjetam->Write();
    hdkjetamo->Write();
    hdkjetam2d->Write();
    hdkjetmeanip->Write();
    hdkjetntr->Write();
    hdkjetmaxip->Write();
    hdkjettrkip->Write();
    hdkjettrkips->Write();
    hdkjettrkw->Write();
    hdkjettrgip->Write();
    hdkjettrkdr->Write();
    ham2dfd->Write();
    ham2dfdk->Write();
    ham2dfb->Write();
    ham2dfgbb->Write();
    ham2dfg->Write();
    ham2dfud->Write();
    ham2dfbpt1->Write();
    ham2dfbpt2->Write();
    ham2dfbpt3->Write();
    ham2dfudpt1->Write();
    ham2dfudpt2->Write();
    ham2dfudpt3->Write();

    hdjetam->Write();
    hdjetam2d->Write();
    hdjetamo->Write();
    hdjetmeanip->Write();
    hdjetntr->Write();
    hdjetmaxip->Write();
    hdjettrkip->Write();
    hdjettrkips->Write();
    hdjettrkw->Write();
    hdjettrgip->Write();
    hdjettrkdr->Write();
    hmeanz->Write();
    hmeanzd->Write();
    hmeanzdk->Write();
    hmeanzfa->Write();
    hmeanzpa->Write();
    hntrkpt1zmpa->Write();
    hntrkpt1zmfa->Write();
    h2dpa->Write();
    h2dfa->Write();
    hmzamd->Write();
    h2damd->Write();
    hmznamd->Write();
    h2dnamd->Write();
    hbigb->Write();
    hpvpre->Write();
    hpvfinal->Write();
    hnvtxpre->Write();
    hnvtxfinal->Write();
    hntrkpre->Write();
    hntrkfinal->Write();
    hjetptfrpre->Write();
    hjetptfrfinal->Write();
    hjntrkpre->Write();
    hjntrkfinal->Write();
    hdzpre->Write();
    hdzfinal->Write();
    hfpilepre->Write();
    hfpilefinal->Write();
    hptmaxpre->Write();
    hptmaxfinal->Write();
    hdzjpre->Write();
    hdzjfinal->Write();
    hsum2Dfpre->Write();
    hsum2Dffinal->Write();
    hsum2Dfd->Write();
    hsum2Dfdk->Write();

    hptallpre->Write();
    hptudpre->Write();
    hptspre->Write();
    hptcpre->Write();
    hptbpre->Write();
    hptgpre->Write();
    hptgbbpre->Write();
    hptallpree->Write();
    hptudpree->Write();
    hptspree->Write();
    hptcpree->Write();
    hptbpree->Write();
    hptgpree->Write();
    hptgbbpree->Write();


    hptallfinal->Write();
    hptudfinal->Write();
    hptsfinal->Write();
    hptcfinal->Write();
    hptbfinal->Write();
    hptgfinal->Write();
    hptgbbfinal->Write();
    hptallfinal2->Write();
    hptudfinal2->Write();
    hptsfinal2->Write();
    hptcfinal2->Write();
    hptbfinal2->Write();
    hptgfinal2->Write();
    hptgbbfinal2->Write();

    hptallfinale->Write();
    hptudfinale->Write();
    hptsfinale->Write();
    hptcfinale->Write();
    hptbfinale->Write();
    hptgfinale->Write();
    hptgbbfinale->Write();

    hmeanzpre->Write();
    hmeanzfinal->Write();

    //2d
    aMip->Write();
    haMvjpt->Write();

    haMvHT->Write();
    haMvnvtx->Write();
    aMbh->Write();
    aMbh2D->Write();
    aMbh2Dd->Write();
    aMbh2Ddk->Write();
    aMbh2Daem->Write();
    aMmzd->Write();
    aMmzdk->Write();

    adkwvd0->Write();
    adwvd0->Write();
    adkwviz->Write();
    adwviz->Write();

    adk2Dr0->Write();
    ad2Dr0->Write();

    hdkipphi->Write();
    hdipphi->Write();

    myfile.Close();
  }

  tt->ResetBranchAddresses();
  
  delete jet_index;
  delete jet_source;
  delete jet_pt;
  delete jet_eta;
  delete jet_phi;
  delete jet_alphaMax;
  delete jet_cef;
  delete jet_nef;
  delete jet_chf;
  //  delete jet_phf;
  delete track_pt;
  delete track_eta;
  delete track_source;
  delete track_quality;
  delete track_index;
  delete track_jet_index;
  delete track_algo;
  delete track_ipZ;
  delete track_ipXY;
  delete track_ipXYSig;
  delete track_ref_x;  
  delete track_ref_y;  
  delete track_ref_z;  


  f->Close();
  


  return npass;
}
